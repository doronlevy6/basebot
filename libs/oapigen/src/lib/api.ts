/* tslint:disable */
/* eslint-disable */
/**
 * Base API
 * The API description of Base\'s API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddCollateralDto
 */
export interface AddCollateralDto {
    /**
     * 
     * @type {string}
     * @memberof AddCollateralDto
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof AddCollateralDto
     */
    'assigneeId': string;
    /**
     * 
     * @type {string}
     * @memberof AddCollateralDto
     */
    'url': string;
}
/**
 * @type AppVersionsControllerGetAppVersionsDefaultResponseValue
 * @export
 */
export type AppVersionsControllerGetAppVersionsDefaultResponseValue = ClientVersionDto;

/**
 * 
 * @export
 * @interface AssigneesAdded
 */
export interface AssigneesAdded {
    /**
     * 
     * @type {Array<MicroUser>}
     * @memberof AssigneesAdded
     */
    'assignees': Array<MicroUser>;
}
/**
 * 
 * @export
 * @interface ClientVersionDto
 */
export interface ClientVersionDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientVersionDto
     */
    'sortedVersions': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ClientVersionDto
     */
    'versionToBuildNumberMapping': object;
}
/**
 * 
 * @export
 * @interface ConvertDraftsDto
 */
export interface ConvertDraftsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConvertDraftsDto
     */
    'draftIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ConvertDraftsResponseDto
 */
export interface ConvertDraftsResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ConvertDraftsResponseDto
     */
    'ok': boolean;
    /**
     * 
     * @type {string}
     * @memberof ConvertDraftsResponseDto
     */
    'error'?: string;
    /**
     * 
     * @type {Array<Task>}
     * @memberof ConvertDraftsResponseDto
     */
    'tasks'?: Array<Task>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationDto
 */
export interface CreateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface CreateTaskDraftDto
 */
export interface CreateTaskDraftDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'assigneeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'dueDateText'?: string;
    /**
     * 
     * @type {DraftOriginDto}
     * @memberof CreateTaskDraftDto
     */
    'origin'?: DraftOriginDto;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {Array<ExternalTicket>}
     * @memberof CreateTaskDraftDto
     */
    'externalTickets'?: Array<ExternalTicket>;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskDraftDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskDraftDto
     */
    'links'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'assigneeId': string;
    /**
     * 
     * @type {Array<ExternalTicket>}
     * @memberof CreateTaskDto
     */
    'externalTickets'?: Array<ExternalTicket>;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskDto
     */
    'links'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteDraftsBulkDto
 */
export interface DeleteDraftsBulkDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteDraftsBulkDto
     */
    'draftIds': Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceToken
 */
export interface DeviceToken {
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'deviceId': string;
    /**
     * 
     * @type {User}
     * @memberof DeviceToken
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'deviceType': DeviceTokenDeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'expoPushToken': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'nativePushToken': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceToken
     */
    'registered': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'updatedAt': string;
}

export const DeviceTokenDeviceTypeEnum = {
    Ios: 'ios',
    Android: 'android',
    Unknown: 'unknown'
} as const;

export type DeviceTokenDeviceTypeEnum = typeof DeviceTokenDeviceTypeEnum[keyof typeof DeviceTokenDeviceTypeEnum];

/**
 * 
 * @export
 * @interface DeviceTokenDto
 */
export interface DeviceTokenDto {
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'deviceType': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'expoPushToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'nativePushToken'?: string;
}
/**
 * 
 * @export
 * @interface DraftOriginDto
 */
export interface DraftOriginDto {
    /**
     * 
     * @type {string}
     * @memberof DraftOriginDto
     */
    'type': DraftOriginDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DraftOriginDto
     */
    'originalText': string;
    /**
     * 
     * @type {object}
     * @memberof DraftOriginDto
     */
    'metadata': object;
}

export const DraftOriginDtoTypeEnum = {
    Email: 'email',
    Slack: 'slack',
    FreeText: 'free_text'
} as const;

export type DraftOriginDtoTypeEnum = typeof DraftOriginDtoTypeEnum[keyof typeof DraftOriginDtoTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EventSource = {
    Slackbot: 'slackbot'
} as const;

export type EventSource = typeof EventSource[keyof typeof EventSource];


/**
 * 
 * @export
 * @interface ExternalLinkCollateral
 */
export interface ExternalLinkCollateral {
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'id': string;
    /**
     * 
     * @type {Task}
     * @memberof ExternalLinkCollateral
     */
    'task': Task;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'taskId': string;
    /**
     * 
     * @type {User}
     * @memberof ExternalLinkCollateral
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'providerType': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalLinkCollateral
     */
    'group': ExternalLinkCollateralGroupEnum;
}

export const ExternalLinkCollateralGroupEnum = {
    Document: 'document',
    Presentation: 'presentation',
    Spreadsheet: 'spreadsheet',
    NonSpecific: 'non_specific',
    Unknown: 'unknown'
} as const;

export type ExternalLinkCollateralGroupEnum = typeof ExternalLinkCollateralGroupEnum[keyof typeof ExternalLinkCollateralGroupEnum];

/**
 * 
 * @export
 * @interface ExternalTicket
 */
export interface ExternalTicket {
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'providerType': string;
    /**
     * 
     * @type {Task}
     * @memberof ExternalTicket
     */
    'task': Task;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'parentTicketId': string;
    /**
     * 
     * @type {User}
     * @memberof ExternalTicket
     */
    'assignee': User;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'assigneeId': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof ExternalTicket
     */
    'providerAssignees': Array<User>;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'status': ExternalTicketStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'providerStatus': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'updatedFromProviderAt': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTicket
     */
    'spaceId': string;
}

export const ExternalTicketStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type ExternalTicketStatusEnum = typeof ExternalTicketStatusEnum[keyof typeof ExternalTicketStatusEnum];

/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200ResponseInfoValue
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface IAnalyticsEvent
 */
export interface IAnalyticsEvent {
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'timestamp'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof IAnalyticsEvent
     */
    'eventSource'?: EventSource;
    /**
     * 
     * @type {object}
     * @memberof IAnalyticsEvent
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface IAnalyticsIdetitiy
 */
export interface IAnalyticsIdetitiy {
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'orgId': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'createdAt': string;
    /**
     * 
     * @type {object}
     * @memberof IAnalyticsIdetitiy
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface ImportFreeTextDto
 */
export interface ImportFreeTextDto {
    /**
     * 
     * @type {string}
     * @memberof ImportFreeTextDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ImportSlackDto
 */
export interface ImportSlackDto {
    /**
     * 
     * @type {string}
     * @memberof ImportSlackDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ImportSlackDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ImportTaskResponse
 */
export interface ImportTaskResponse {
    /**
     * 
     * @type {Array<TaskDraft>}
     * @memberof ImportTaskResponse
     */
    'drafts': Array<TaskDraft>;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'group': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'provider': string;
}
/**
 * 
 * @export
 * @interface MessengerMessage
 */
export interface MessengerMessage {
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'userEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'channelId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof MessengerMessage
     */
    'blocks'?: object;
}
/**
 * 
 * @export
 * @interface MicroUser
 */
export interface MicroUser {
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'imageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'domain': string;
    /**
     * 
     * @type {OrganizationSettings}
     * @memberof Organization
     */
    'settings': OrganizationSettings;
    /**
     * 
     * @type {Array<User>}
     * @memberof Organization
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationSettings
     */
    'organization': Organization;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'organizationId': string;
    /**
     * 
     * @type {OrganizationSettingsDto}
     * @memberof OrganizationSettings
     */
    'settings': OrganizationSettingsDto;
}
/**
 * 
 * @export
 * @interface OrganizationSettingsDto
 */
export interface OrganizationSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'slackTeamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'preferredMessenger'?: string;
}
/**
 * 
 * @export
 * @interface PushNotificationDto
 */
export interface PushNotificationDto {
    /**
     * 
     * @type {PushNotificationDtoNotificationData}
     * @memberof PushNotificationDto
     */
    'notificationData': PushNotificationDtoNotificationData;
    /**
     * 
     * @type {string}
     * @memberof PushNotificationDto
     */
    'notifiedUserId': string;
    /**
     * 
     * @type {string}
     * @memberof PushNotificationDto
     */
    'type': PushNotificationDtoTypeEnum;
}

export const PushNotificationDtoTypeEnum = {
    StatusChanged: 'task_status_changed',
    DueDateChanged: 'task_due_date_changed'
} as const;

export type PushNotificationDtoTypeEnum = typeof PushNotificationDtoTypeEnum[keyof typeof PushNotificationDtoTypeEnum];

/**
 * @type PushNotificationDtoNotificationData
 * @export
 */
export type PushNotificationDtoNotificationData = TaskDueDateChangeNotification | TaskStatusChangeNotification;

/**
 * 
 * @export
 * @interface RecentActivity
 */
export interface RecentActivity {
    /**
     * 
     * @type {RecentActivityData}
     * @memberof RecentActivity
     */
    'data': RecentActivityData;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'id': string;
    /**
     * 
     * @type {Task}
     * @memberof RecentActivity
     */
    'task': Task;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'taskId': string;
    /**
     * 
     * @type {User}
     * @memberof RecentActivity
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'type': RecentActivityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'origin': RecentActivityOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'updatedAt': string;
}

export const RecentActivityTypeEnum = {
    Link: 'link',
    TaskStatusChanged: 'task_status_changed',
    TicketStatusChanged: 'ticket_status_changed',
    TaskPostponed: 'task_postponed',
    TicketPostponed: 'ticket_postponed',
    AssigneesAdded: 'assignees_added'
} as const;

export type RecentActivityTypeEnum = typeof RecentActivityTypeEnum[keyof typeof RecentActivityTypeEnum];
export const RecentActivityOriginEnum = {
    Null: 'null',
    Empty: '',
    ManuallyAdded: 'manually_added',
    Slack: 'slack',
    Email: 'email',
    System: 'system'
} as const;

export type RecentActivityOriginEnum = typeof RecentActivityOriginEnum[keyof typeof RecentActivityOriginEnum];

/**
 * @type RecentActivityData
 * @export
 */
export type RecentActivityData = AssigneesAdded | Link | TaskPostponement | TaskStatusChange | TicketPostponement | TicketStatusChange;

/**
 * 
 * @export
 * @interface SlackUpdateTaskDto
 */
export interface SlackUpdateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'status'?: SlackUpdateTaskDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'assigneeId': string;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ExternalTicket>}
     * @memberof SlackUpdateTaskDto
     */
    'externalTickets'?: Array<ExternalTicket>;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlackUpdateTaskDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlackUpdateTaskDto
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'id'?: string;
}

export const SlackUpdateTaskDtoStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type SlackUpdateTaskDtoStatusEnum = typeof SlackUpdateTaskDtoStatusEnum[keyof typeof SlackUpdateTaskDtoStatusEnum];

/**
 * 
 * @export
 * @interface SlackUserDto
 */
export interface SlackUserDto {
    /**
     * 
     * @type {string}
     * @memberof SlackUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SlackUserDto
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof SlackUserDto
     */
    'profileImage': string;
    /**
     * 
     * @type {number}
     * @memberof SlackUserDto
     */
    'timezoneOffset': number;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'status': TaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof Task
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'followers': string;
    /**
     * 
     * @type {User}
     * @memberof Task
     */
    'assignee': User;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'assigneeId': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Task
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<ExternalLinkCollateral>}
     * @memberof Task
     */
    'externalLinks'?: Array<ExternalLinkCollateral>;
    /**
     * 
     * @type {Array<ExternalTicket>}
     * @memberof Task
     */
    'externalTickets'?: Array<ExternalTicket>;
    /**
     * 
     * @type {Array<RecentActivity>}
     * @memberof Task
     */
    'recentActivityLog'?: Array<RecentActivity>;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'deletedAt'?: string;
}

export const TaskStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];

/**
 * 
 * @export
 * @interface TaskChangeNotification
 */
export interface TaskChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'taskDescription': string;
}
/**
 * 
 * @export
 * @interface TaskDraft
 */
export interface TaskDraft {
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof TaskDraft
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'description'?: string;
    /**
     * 
     * @type {User}
     * @memberof TaskDraft
     */
    'assignee'?: User;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'assigneeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'dueDateText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskDraft
     */
    'convertedToTask': boolean;
    /**
     * 
     * @type {DraftOriginDto}
     * @memberof TaskDraft
     */
    'origin'?: DraftOriginDto;
}
/**
 * 
 * @export
 * @interface TaskDueDateChangeNotification
 */
export interface TaskDueDateChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'changerId': string;
    /**
     * 
     * @type {object}
     * @memberof TaskDueDateChangeNotification
     */
    'previousDueDate'?: object;
    /**
     * 
     * @type {object}
     * @memberof TaskDueDateChangeNotification
     */
    'currentDueDate'?: object;
}
/**
 * 
 * @export
 * @interface TaskPostponement
 */
export interface TaskPostponement {
    /**
     * 
     * @type {string}
     * @memberof TaskPostponement
     */
    'previousDueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskPostponement
     */
    'currentDueDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskPostponement
     */
    'changeTime': number;
}
/**
 * 
 * @export
 * @interface TaskStatusChange
 */
export interface TaskStatusChange {
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChange
     */
    'previousStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChange
     */
    'currentStatus': string;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusChange
     */
    'changeTime': number;
}
/**
 * 
 * @export
 * @interface TaskStatusChangeNotification
 */
export interface TaskStatusChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'changerId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'changeTrigger'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'previousStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'currentStatus': string;
}
/**
 * 
 * @export
 * @interface TaskStatusUpdateRequestDto
 */
export interface TaskStatusUpdateRequestDto {
    /**
     * 
     * @type {User}
     * @memberof TaskStatusUpdateRequestDto
     */
    'user': User;
    /**
     * 
     * @type {Task}
     * @memberof TaskStatusUpdateRequestDto
     */
    'task': Task;
    /**
     * 
     * @type {boolean}
     * @memberof TaskStatusUpdateRequestDto
     */
    'firstTimeAsking': boolean;
}
/**
 * 
 * @export
 * @interface TicketPostponement
 */
export interface TicketPostponement {
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'previousDueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'currentDueDate'?: string;
}
/**
 * 
 * @export
 * @interface TicketStatusChange
 */
export interface TicketStatusChange {
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'previousStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'currentStatus': string;
}
/**
 * 
 * @export
 * @interface UpdateAndConvertDraftResponseDto
 */
export interface UpdateAndConvertDraftResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAndConvertDraftResponseDto
     */
    'ok': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateAndConvertDraftResponseDto
     */
    'error'?: string;
    /**
     * 
     * @type {Task}
     * @memberof UpdateAndConvertDraftResponseDto
     */
    'task'?: Task;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationDto
 */
export interface UpdateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface UpdateSettingsDto
 */
export interface UpdateSettingsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSettingsDto
     */
    'teamDomains': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'teamDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'teamLogo': string;
}
/**
 * 
 * @export
 * @interface UpdateTaskDraftDto
 */
export interface UpdateTaskDraftDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'assigneeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'dueDateText'?: string;
    /**
     * 
     * @type {DraftOriginDto}
     * @memberof UpdateTaskDraftDto
     */
    'origin'?: DraftOriginDto;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {Array<ExternalTicket>}
     * @memberof UpdateTaskDraftDto
     */
    'externalTickets'?: Array<ExternalTicket>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateTaskDraftDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateTaskDraftDto
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UpdateTaskDto
 */
export interface UpdateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'status'?: UpdateTaskDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {Array<ExternalTicket>}
     * @memberof UpdateTaskDto
     */
    'externalTickets'?: Array<ExternalTicket>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateTaskDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateTaskDto
     */
    'links'?: Array<string>;
}

export const UpdateTaskDtoStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type UpdateTaskDtoStatusEnum = typeof UpdateTaskDtoStatusEnum[keyof typeof UpdateTaskDtoStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileImage': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'externalAuthId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UsersImportDto
 */
export interface UsersImportDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersImportDto
     */
    'teamDomains': Array<string>;
    /**
     * 
     * @type {Array<SlackUserDto>}
     * @memberof UsersImportDto
     */
    'users': Array<SlackUserDto>;
}

/**
 * AppVersionsApi - axios parameter creator
 * @export
 */
export const AppVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appVersionsControllerGetAppVersions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app-versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppVersionsApi - functional programming interface
 * @export
 */
export const AppVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appVersionsControllerGetAppVersions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appVersionsControllerGetAppVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppVersionsApi - factory interface
 * @export
 */
export const AppVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppVersionsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appVersionsControllerGetAppVersions(options?: any): AxiosPromise<object> {
            return localVarFp.appVersionsControllerGetAppVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppVersionsApi - object-oriented interface
 * @export
 * @class AppVersionsApi
 * @extends {BaseAPI}
 */
export class AppVersionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    public appVersionsControllerGetAppVersions(options?: AxiosRequestConfig) {
        return AppVersionsApiFp(this.configuration).appVersionsControllerGetAppVersions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: any): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: any): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthControllerCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ImportFreeTextDto} importFreeTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateDraftsFromFreeText: async (importFreeTextDto: ImportFreeTextDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importFreeTextDto' is not null or undefined
            assertParamExists('importTasksControllerCreateDraftsFromFreeText', 'importFreeTextDto', importFreeTextDto)
            const localVarPath = `/import-tasks/free-text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importFreeTextDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateTasksFromEmails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import-tasks/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ImportFreeTextDto} importFreeTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTasksControllerCreateDraftsFromFreeText(importFreeTextDto: ImportFreeTextDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTasksControllerCreateDraftsFromFreeText(importFreeTextDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTasksControllerCreateTasksFromEmails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTasksControllerCreateTasksFromEmails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * 
         * @param {ImportFreeTextDto} importFreeTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateDraftsFromFreeText(importFreeTextDto: ImportFreeTextDto, options?: any): AxiosPromise<ImportTaskResponse> {
            return localVarFp.importTasksControllerCreateDraftsFromFreeText(importFreeTextDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateTasksFromEmails(options?: any): AxiosPromise<void> {
            return localVarFp.importTasksControllerCreateTasksFromEmails(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * 
     * @param {ImportFreeTextDto} importFreeTextDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importTasksControllerCreateDraftsFromFreeText(importFreeTextDto: ImportFreeTextDto, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).importTasksControllerCreateDraftsFromFreeText(importFreeTextDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importTasksControllerCreateTasksFromEmails(options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).importTasksControllerCreateTasksFromEmails(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OauthPublicApi - axios parameter creator
 * @export
 */
export const OauthPublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGetUserProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-public/my-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthPublicApi - functional programming interface
 * @export
 */
export const OauthPublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OauthPublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthPublicControllerGetUserProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthPublicControllerGetUserProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OauthPublicApi - factory interface
 * @export
 */
export const OauthPublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OauthPublicApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGetUserProviders(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.oauthPublicControllerGetUserProviders(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OauthPublicApi - object-oriented interface
 * @export
 * @class OauthPublicApi
 * @extends {BaseAPI}
 */
export class OauthPublicApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthPublicApi
     */
    public oauthPublicControllerGetUserProviders(options?: AxiosRequestConfig) {
        return OauthPublicApiFp(this.configuration).oauthPublicControllerGetUserProviders(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationSettingsApi - axios parameter creator
 * @export
 */
export const OrganizationSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerFindOne: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrganizationSettingsDto} organizationSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerUpdate: async (organizationSettingsDto: OrganizationSettingsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettingsDto' is not null or undefined
            assertParamExists('organizationSettingsControllerUpdate', 'organizationSettingsDto', organizationSettingsDto)
            const localVarPath = `/organization-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationSettingsApi - functional programming interface
 * @export
 */
export const OrganizationSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSettingsControllerFindOne(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSettingsControllerFindOne(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrganizationSettingsDto} organizationSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSettingsControllerUpdate(organizationSettingsDto: OrganizationSettingsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSettingsControllerUpdate(organizationSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationSettingsApi - factory interface
 * @export
 */
export const OrganizationSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationSettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerFindOne(options?: any): AxiosPromise<OrganizationSettings> {
            return localVarFp.organizationSettingsControllerFindOne(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrganizationSettingsDto} organizationSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerUpdate(organizationSettingsDto: OrganizationSettingsDto, options?: any): AxiosPromise<OrganizationSettings> {
            return localVarFp.organizationSettingsControllerUpdate(organizationSettingsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationSettingsApi - object-oriented interface
 * @export
 * @class OrganizationSettingsApi
 * @extends {BaseAPI}
 */
export class OrganizationSettingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationSettingsApi
     */
    public organizationSettingsControllerFindOne(options?: AxiosRequestConfig) {
        return OrganizationSettingsApiFp(this.configuration).organizationSettingsControllerFindOne(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrganizationSettingsDto} organizationSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationSettingsApi
     */
    public organizationSettingsControllerUpdate(organizationSettingsDto: OrganizationSettingsDto, options?: AxiosRequestConfig) {
        return OrganizationSettingsApiFp(this.configuration).organizationSettingsControllerUpdate(organizationSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerCreate: async (createOrganizationDto: CreateOrganizationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationDto' is not null or undefined
            assertParamExists('organizationsControllerCreate', 'createOrganizationDto', createOrganizationDto)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerFindOne', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerRemove', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerUpdate: async (id: string, updateOrganizationDto: UpdateOrganizationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerUpdate', 'id', id)
            // verify required parameter 'updateOrganizationDto' is not null or undefined
            assertParamExists('organizationsControllerUpdate', 'updateOrganizationDto', updateOrganizationDto)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerCreate(createOrganizationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerUpdate(id: string, updateOrganizationDto: UpdateOrganizationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerUpdate(id, updateOrganizationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: any): AxiosPromise<Organization> {
            return localVarFp.organizationsControllerCreate(createOrganizationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindAll(options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.organizationsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.organizationsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerUpdate(id: string, updateOrganizationDto: UpdateOrganizationDto, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsControllerUpdate(id, updateOrganizationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrganizationDto} createOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerCreate(createOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerFindAll(options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateOrganizationDto} updateOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerUpdate(id: string, updateOrganizationDto: UpdateOrganizationDto, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerUpdate(id, updateOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PushNotificationsApi - axios parameter creator
 * @export
 */
export const PushNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceTokenDto} deviceTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationsControllerCreateOrUpdate: async (deviceTokenDto: DeviceTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceTokenDto' is not null or undefined
            assertParamExists('pushNotificationsControllerCreateOrUpdate', 'deviceTokenDto', deviceTokenDto)
            const localVarPath = `/push-notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationsApi - functional programming interface
 * @export
 */
export const PushNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeviceTokenDto} deviceTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationsControllerCreateOrUpdate(deviceTokenDto: DeviceTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationsControllerCreateOrUpdate(deviceTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PushNotificationsApi - factory interface
 * @export
 */
export const PushNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushNotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {DeviceTokenDto} deviceTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationsControllerCreateOrUpdate(deviceTokenDto: DeviceTokenDto, options?: any): AxiosPromise<DeviceToken> {
            return localVarFp.pushNotificationsControllerCreateOrUpdate(deviceTokenDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushNotificationsApi - object-oriented interface
 * @export
 * @class PushNotificationsApi
 * @extends {BaseAPI}
 */
export class PushNotificationsApi extends BaseAPI {
    /**
     * 
     * @param {DeviceTokenDto} deviceTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public pushNotificationsControllerCreateOrUpdate(deviceTokenDto: DeviceTokenDto, options?: AxiosRequestConfig) {
        return PushNotificationsApiFp(this.configuration).pushNotificationsControllerCreateOrUpdate(deviceTokenDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecentActivityApi - axios parameter creator
 * @export
 */
export const RecentActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerLoadActivity: async (taskId: string, limit: number, offset: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('recentActivityControllerLoadActivity', 'taskId', taskId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('recentActivityControllerLoadActivity', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('recentActivityControllerLoadActivity', 'offset', offset)
            const localVarPath = `/recent-activity/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecentActivityApi - functional programming interface
 * @export
 */
export const RecentActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecentActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentActivityControllerLoadActivity(taskId: string, limit: number, offset: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecentActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentActivityControllerLoadActivity(taskId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecentActivityApi - factory interface
 * @export
 */
export const RecentActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecentActivityApiFp(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerLoadActivity(taskId: string, limit: number, offset: number, options?: any): AxiosPromise<Array<RecentActivity>> {
            return localVarFp.recentActivityControllerLoadActivity(taskId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecentActivityApi - object-oriented interface
 * @export
 * @class RecentActivityApi
 * @extends {BaseAPI}
 */
export class RecentActivityApi extends BaseAPI {
    /**
     * 
     * @param {string} taskId 
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentActivityApi
     */
    public recentActivityControllerLoadActivity(taskId: string, limit: number, offset: number, options?: AxiosRequestConfig) {
        return RecentActivityApiFp(this.configuration).recentActivityControllerLoadActivity(taskId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SlackbotApiApi - axios parameter creator
 * @export
 */
export const SlackbotApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddCollateralDto} addCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAddCollateral: async (addCollateralDto: AddCollateralDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCollateralDto' is not null or undefined
            assertParamExists('slackbotApiControllerAddCollateral', 'addCollateralDto', addCollateralDto)
            const localVarPath = `/slackbot-api/collaterals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCollateralDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsersImportDto} usersImportDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreate: async (usersImportDto: UsersImportDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersImportDto' is not null or undefined
            assertParamExists('slackbotApiControllerCreate', 'usersImportDto', usersImportDto)
            const localVarPath = `/slackbot-api/import/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersImportDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportSlackDto} importSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreateTasksFromSlackMessage: async (importSlackDto: ImportSlackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importSlackDto' is not null or undefined
            assertParamExists('slackbotApiControllerCreateTasksFromSlackMessage', 'importSlackDto', importSlackDto)
            const localVarPath = `/slackbot-api/create-drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importSlackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdate: async (id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slackbotApiControllerUpdate', 'id', id)
            // verify required parameter 'slackUpdateTaskDto' is not null or undefined
            assertParamExists('slackbotApiControllerUpdate', 'slackUpdateTaskDto', slackUpdateTaskDto)
            const localVarPath = `/slackbot-api/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackUpdateTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdateSettings: async (updateSettingsDto: UpdateSettingsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSettingsDto' is not null or undefined
            assertParamExists('slackbotApiControllerUpdateSettings', 'updateSettingsDto', updateSettingsDto)
            const localVarPath = `/slackbot-api/organization-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlackbotApiApi - functional programming interface
 * @export
 */
export const SlackbotApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlackbotApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddCollateralDto} addCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerAddCollateral(addCollateralDto: AddCollateralDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerAddCollateral(addCollateralDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UsersImportDto} usersImportDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerCreate(usersImportDto: UsersImportDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerCreate(usersImportDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportSlackDto} importSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto: ImportSlackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerUpdate(id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerUpdate(id, slackUpdateTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerUpdateSettings(updateSettingsDto: UpdateSettingsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerUpdateSettings(updateSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SlackbotApiApi - factory interface
 * @export
 */
export const SlackbotApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlackbotApiApiFp(configuration)
    return {
        /**
         * 
         * @param {AddCollateralDto} addCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAddCollateral(addCollateralDto: AddCollateralDto, options?: any): AxiosPromise<void> {
            return localVarFp.slackbotApiControllerAddCollateral(addCollateralDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsersImportDto} usersImportDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreate(usersImportDto: UsersImportDto, options?: any): AxiosPromise<void> {
            return localVarFp.slackbotApiControllerCreate(usersImportDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportSlackDto} importSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto: ImportSlackDto, options?: any): AxiosPromise<void> {
            return localVarFp.slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdate(id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.slackbotApiControllerUpdate(id, slackUpdateTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdateSettings(updateSettingsDto: UpdateSettingsDto, options?: any): AxiosPromise<OrganizationSettings> {
            return localVarFp.slackbotApiControllerUpdateSettings(updateSettingsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlackbotApiApi - object-oriented interface
 * @export
 * @class SlackbotApiApi
 * @extends {BaseAPI}
 */
export class SlackbotApiApi extends BaseAPI {
    /**
     * 
     * @param {AddCollateralDto} addCollateralDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerAddCollateral(addCollateralDto: AddCollateralDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerAddCollateral(addCollateralDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersImportDto} usersImportDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerCreate(usersImportDto: UsersImportDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerCreate(usersImportDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportSlackDto} importSlackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto: ImportSlackDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerUpdate(id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerUpdate(id, slackUpdateTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateSettingsDto} updateSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerUpdateSettings(updateSettingsDto: UpdateSettingsDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerUpdateSettings(updateSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskDraftsApi - axios parameter creator
 * @export
 */
export const TaskDraftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConvertDraftsDto} convertDraftsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerConvertToTasks: async (convertDraftsDto: ConvertDraftsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'convertDraftsDto' is not null or undefined
            assertParamExists('taskDraftsControllerConvertToTasks', 'convertDraftsDto', convertDraftsDto)
            const localVarPath = `/task-drafts/convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(convertDraftsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTaskDraftDto} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreate: async (createTaskDraftDto: CreateTaskDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerCreate', 'createTaskDraftDto', createTaskDraftDto)
            const localVarPath = `/task-drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreateBulk: async (createTaskDraftDto: Array<CreateTaskDraftDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerCreateBulk', 'createTaskDraftDto', createTaskDraftDto)
            const localVarPath = `/task-drafts/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindDraftsByCreator: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task-drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskDraftsControllerFindOne', 'id', id)
            const localVarPath = `/task-drafts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskDraftsControllerRemove', 'id', id)
            const localVarPath = `/task-drafts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemoveBulk: async (deleteDraftsBulkDto: DeleteDraftsBulkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteDraftsBulkDto' is not null or undefined
            assertParamExists('taskDraftsControllerRemoveBulk', 'deleteDraftsBulkDto', deleteDraftsBulkDto)
            const localVarPath = `/task-drafts/delete-bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDraftsBulkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdate: async (id: string, updateTaskDraftDto: UpdateTaskDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskDraftsControllerUpdate', 'id', id)
            // verify required parameter 'updateTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerUpdate', 'updateTaskDraftDto', updateTaskDraftDto)
            const localVarPath = `/task-drafts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdateAndConverToTask: async (updateTaskDraftDto: UpdateTaskDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerUpdateAndConverToTask', 'updateTaskDraftDto', updateTaskDraftDto)
            const localVarPath = `/task-drafts/update-and-convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskDraftsApi - functional programming interface
 * @export
 */
export const TaskDraftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskDraftsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConvertDraftsDto} convertDraftsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerConvertToTasks(convertDraftsDto: ConvertDraftsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConvertDraftsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerConvertToTasks(convertDraftsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTaskDraftDto} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerCreate(createTaskDraftDto: CreateTaskDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerCreate(createTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerCreateBulk(createTaskDraftDto: Array<CreateTaskDraftDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDraft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerCreateBulk(createTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerFindDraftsByCreator(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDraft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerFindDraftsByCreator(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerRemoveBulk(deleteDraftsBulkDto: DeleteDraftsBulkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerRemoveBulk(deleteDraftsBulkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerUpdate(id: string, updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerUpdate(id, updateTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAndConvertDraftResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskDraftsApi - factory interface
 * @export
 */
export const TaskDraftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskDraftsApiFp(configuration)
    return {
        /**
         * 
         * @param {ConvertDraftsDto} convertDraftsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerConvertToTasks(convertDraftsDto: ConvertDraftsDto, options?: any): AxiosPromise<ConvertDraftsResponseDto> {
            return localVarFp.taskDraftsControllerConvertToTasks(convertDraftsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTaskDraftDto} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreate(createTaskDraftDto: CreateTaskDraftDto, options?: any): AxiosPromise<TaskDraft> {
            return localVarFp.taskDraftsControllerCreate(createTaskDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreateBulk(createTaskDraftDto: Array<CreateTaskDraftDto>, options?: any): AxiosPromise<Array<TaskDraft>> {
            return localVarFp.taskDraftsControllerCreateBulk(createTaskDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindDraftsByCreator(options?: any): AxiosPromise<Array<TaskDraft>> {
            return localVarFp.taskDraftsControllerFindDraftsByCreator(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.taskDraftsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.taskDraftsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemoveBulk(deleteDraftsBulkDto: DeleteDraftsBulkDto, options?: any): AxiosPromise<void> {
            return localVarFp.taskDraftsControllerRemoveBulk(deleteDraftsBulkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdate(id: string, updateTaskDraftDto: UpdateTaskDraftDto, options?: any): AxiosPromise<void> {
            return localVarFp.taskDraftsControllerUpdate(id, updateTaskDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto: UpdateTaskDraftDto, options?: any): AxiosPromise<UpdateAndConvertDraftResponseDto> {
            return localVarFp.taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskDraftsApi - object-oriented interface
 * @export
 * @class TaskDraftsApi
 * @extends {BaseAPI}
 */
export class TaskDraftsApi extends BaseAPI {
    /**
     * 
     * @param {ConvertDraftsDto} convertDraftsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerConvertToTasks(convertDraftsDto: ConvertDraftsDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerConvertToTasks(convertDraftsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTaskDraftDto} createTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerCreate(createTaskDraftDto: CreateTaskDraftDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerCreate(createTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerCreateBulk(createTaskDraftDto: Array<CreateTaskDraftDto>, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerCreateBulk(createTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerFindDraftsByCreator(options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerFindDraftsByCreator(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerRemoveBulk(deleteDraftsBulkDto: DeleteDraftsBulkDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerRemoveBulk(deleteDraftsBulkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTaskDraftDto} updateTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerUpdate(id: string, updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerUpdate(id, updateTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateTaskDraftDto} updateTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskStatusUpdateSchedulerApi - axios parameter creator
 * @export
 */
export const TaskStatusUpdateSchedulerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskStatusUpdateSchedulerControllerRequestStatusUpdate: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('taskStatusUpdateSchedulerControllerRequestStatusUpdate', 'taskId', taskId)
            const localVarPath = `/task-status-update-scheduler/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskStatusUpdateSchedulerApi - functional programming interface
 * @export
 */
export const TaskStatusUpdateSchedulerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskStatusUpdateSchedulerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskStatusUpdateSchedulerControllerRequestStatusUpdate(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskStatusUpdateSchedulerControllerRequestStatusUpdate(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskStatusUpdateSchedulerApi - factory interface
 * @export
 */
export const TaskStatusUpdateSchedulerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskStatusUpdateSchedulerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskStatusUpdateSchedulerControllerRequestStatusUpdate(taskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.taskStatusUpdateSchedulerControllerRequestStatusUpdate(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskStatusUpdateSchedulerApi - object-oriented interface
 * @export
 * @class TaskStatusUpdateSchedulerApi
 * @extends {BaseAPI}
 */
export class TaskStatusUpdateSchedulerApi extends BaseAPI {
    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskStatusUpdateSchedulerApi
     */
    public taskStatusUpdateSchedulerControllerRequestStatusUpdate(taskId: string, options?: AxiosRequestConfig) {
        return TaskStatusUpdateSchedulerApiFp(this.configuration).taskStatusUpdateSchedulerControllerRequestStatusUpdate(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreate: async (createTaskDto: CreateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('tasksControllerCreate', 'createTaskDto', createTaskDto)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CreateTaskDto>} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreateBulk: async (createTaskDto: Array<CreateTaskDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('tasksControllerCreateBulk', 'createTaskDto', createTaskDto)
            const localVarPath = `/tasks/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerFindOne', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindTasksByCreator: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerRemove', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdate: async (id: string, updateTaskDto: UpdateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerUpdate', 'id', id)
            // verify required parameter 'updateTaskDto' is not null or undefined
            assertParamExists('tasksControllerUpdate', 'updateTaskDto', updateTaskDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerCreate(createTaskDto: CreateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerCreate(createTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<CreateTaskDto>} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerCreateBulk(createTaskDto: Array<CreateTaskDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerCreateBulk(createTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerFindTasksByCreator(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerFindTasksByCreator(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerUpdate(id, updateTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreate(createTaskDto: CreateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksControllerCreate(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CreateTaskDto>} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreateBulk(createTaskDto: Array<CreateTaskDto>, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksControllerCreateBulk(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindOne(id: string, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindTasksByCreator(limit?: number, offset?: number, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksControllerFindTasksByCreator(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.tasksControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksControllerUpdate(id, updateTaskDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerCreate(createTaskDto: CreateTaskDto, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerCreate(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CreateTaskDto>} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerCreateBulk(createTaskDto: Array<CreateTaskDto>, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerCreateBulk(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerFindTasksByCreator(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerFindTasksByCreator(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerRemove(id: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTaskDto} updateTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerUpdate(id, updateTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerFindOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate: async (id: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('usersControllerUpdate', 'body', body)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdate(id: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.usersControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.usersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate(id: string, body: object, options?: any): AxiosPromise<object> {
            return localVarFp.usersControllerUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindAll(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUpdate(id: string, body: object, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


