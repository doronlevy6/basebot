/* tslint:disable */
/* eslint-disable */
/**
 * Base API
 * The API description of Base\'s API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AcknowledgeTaskDto
 */
export interface AcknowledgeTaskDto {
    /**
     * 
     * @type {boolean}
     * @memberof AcknowledgeTaskDto
     */
    'acknowledged': boolean;
    /**
     * 
     * @type {string}
     * @memberof AcknowledgeTaskDto
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof AcknowledgeTaskDto
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof AcknowledgeTaskDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface AddCollateralDto
 */
export interface AddCollateralDto {
    /**
     * 
     * @type {string}
     * @memberof AddCollateralDto
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof AddCollateralDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof AddCollateralDto
     */
    'creatorComment'?: string;
}
/**
 * 
 * @export
 * @interface AddDiscussionFromSlackDto
 */
export interface AddDiscussionFromSlackDto {
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'originalCreatorEmail': string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'externalId': string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'externalParentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'creatorEmail': string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'rawText': string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'sanitizedText'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDiscussionFromSlackDto
     */
    'updatedAt'?: string;
}
/**
 * @type AppVersionsControllerGetAppVersionsDefaultResponseValue
 * @export
 */
export type AppVersionsControllerGetAppVersionsDefaultResponseValue = ClientVersionDto;

/**
 * 
 * @export
 * @interface CalendarAttendee
 */
export interface CalendarAttendee {
    /**
     * 
     * @type {string}
     * @memberof CalendarAttendee
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarAttendee
     */
    'status': CalendarAttendeeStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CalendarAttendee
     */
    'displayName'?: string;
}

export const CalendarAttendeeStatusEnum = {
    Accepted: 'accepted',
    Declined: 'declined',
    NeedsAction: 'needsAction'
} as const;

export type CalendarAttendeeStatusEnum = typeof CalendarAttendeeStatusEnum[keyof typeof CalendarAttendeeStatusEnum];

/**
 * 
 * @export
 * @interface CalendarCollateral
 */
export interface CalendarCollateral {
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'calendarId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'description'?: string;
    /**
     * 
     * @type {Array<CalendarAttendee>}
     * @memberof CalendarCollateral
     */
    'attendees': Array<CalendarAttendee>;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'reccuringEventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarCollateral
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ClientVersionDto
 */
export interface ClientVersionDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientVersionDto
     */
    'sortedVersions': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ClientVersionDto
     */
    'versionToBuildNumberMapping': object;
}
/**
 * 
 * @export
 * @interface Collateral
 */
export interface Collateral {
    /**
     * 
     * @type {CollateralData}
     * @memberof Collateral
     */
    'data': CollateralData;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'type': CollateralTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'url': string;
    /**
     * 
     * @type {Task}
     * @memberof Collateral
     */
    'task': Task;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'taskId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Collateral
     */
    'taskIsDeleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Collateral
     */
    'refreshable': boolean;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'lastSync'?: string;
    /**
     * 
     * @type {User}
     * @memberof Collateral
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<DiscussionMessage>}
     * @memberof Collateral
     */
    'discussionMessages'?: Array<DiscussionMessage>;
    /**
     * 
     * @type {string}
     * @memberof Collateral
     */
    'creatorComment'?: string;
}

export const CollateralTypeEnum = {
    Link: 'link',
    File: 'file',
    Ticket: 'ticket',
    Calendar: 'calendar',
    Unknown: 'unknown'
} as const;

export type CollateralTypeEnum = typeof CollateralTypeEnum[keyof typeof CollateralTypeEnum];

/**
 * @type CollateralData
 * @export
 */
export type CollateralData = CalendarCollateral | ForbiddenTicketCollateral | LinkCollateral | TicketCollateral;

/**
 * 
 * @export
 * @interface ContributorsChanged
 */
export interface ContributorsChanged {
    /**
     * 
     * @type {Array<MicroUser>}
     * @memberof ContributorsChanged
     */
    'contributors': Array<MicroUser>;
}
/**
 * 
 * @export
 * @interface ConvertDraftsDto
 */
export interface ConvertDraftsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConvertDraftsDto
     */
    'draftIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ConvertDraftsResponseDto
 */
export interface ConvertDraftsResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof ConvertDraftsResponseDto
     */
    'ok': boolean;
    /**
     * 
     * @type {string}
     * @memberof ConvertDraftsResponseDto
     */
    'error'?: string;
    /**
     * 
     * @type {Array<Task>}
     * @memberof ConvertDraftsResponseDto
     */
    'tasks'?: Array<Task>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationDto
 */
export interface CreateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface CreateTaskDraftDto
 */
export interface CreateTaskDraftDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'assigneeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'ownerText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'dueDateText'?: string;
    /**
     * 
     * @type {DraftOriginDto}
     * @memberof CreateTaskDraftDto
     */
    'origin'?: DraftOriginDto;
    /**
     * 
     * @type {Array<ImportTaskUser>}
     * @memberof CreateTaskDraftDto
     */
    'possibleContributors'?: Array<ImportTaskUser>;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskDraftDto
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDraftDto
     */
    'dueDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateTaskDto
 */
export interface CreateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskDto
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskDto
     */
    'dueDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateTaskWithCollateralsDto
 */
export interface CreateTaskWithCollateralsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskWithCollateralsDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskWithCollateralsDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskWithCollateralsDto
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskWithCollateralsDto
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskWithCollateralsDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskWithCollateralsDto
     */
    'urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteDraftsBulkDto
 */
export interface DeleteDraftsBulkDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteDraftsBulkDto
     */
    'draftIds': Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceToken
 */
export interface DeviceToken {
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'deviceId': string;
    /**
     * 
     * @type {User}
     * @memberof DeviceToken
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'deviceType': DeviceTokenDeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'expoPushToken': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'nativePushToken': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceToken
     */
    'registered': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceToken
     */
    'updatedAt': string;
}

export const DeviceTokenDeviceTypeEnum = {
    Ios: 'ios',
    Android: 'android',
    Unknown: 'unknown'
} as const;

export type DeviceTokenDeviceTypeEnum = typeof DeviceTokenDeviceTypeEnum[keyof typeof DeviceTokenDeviceTypeEnum];

/**
 * 
 * @export
 * @interface DeviceTokenDto
 */
export interface DeviceTokenDto {
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'deviceType': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'expoPushToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTokenDto
     */
    'nativePushToken'?: string;
}
/**
 * 
 * @export
 * @interface DiscussionAdded
 */
export interface DiscussionAdded {
    /**
     * 
     * @type {string}
     * @memberof DiscussionAdded
     */
    'discussionMessageId': string;
    /**
     * 
     * @type {string}
     * @memberof DiscussionAdded
     */
    'text': string;
    /**
     * 
     * @type {number}
     * @memberof DiscussionAdded
     */
    'createdAt': number;
    /**
     * 
     * @type {MicroUser}
     * @memberof DiscussionAdded
     */
    'originalMessageCreator': MicroUser;
    /**
     * 
     * @type {string}
     * @memberof DiscussionAdded
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface DiscussionMessage
 */
export interface DiscussionMessage {
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'parentId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DiscussionMessage
     */
    'externalOrigin': boolean;
    /**
     * 
     * @type {User}
     * @memberof DiscussionMessage
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'sanitizedText': string;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'rawText': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DiscussionMessage
     */
    'detectedLinks': Array<string>;
    /**
     * 
     * @type {Task}
     * @memberof DiscussionMessage
     */
    'task': Task;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'taskId': string;
    /**
     * 
     * @type {Collateral}
     * @memberof DiscussionMessage
     */
    'collateral'?: Collateral;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'collateralId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DiscussionMessage
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface DraftOriginDto
 */
export interface DraftOriginDto {
    /**
     * 
     * @type {string}
     * @memberof DraftOriginDto
     */
    'type': DraftOriginDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DraftOriginDto
     */
    'originalText': string;
    /**
     * 
     * @type {object}
     * @memberof DraftOriginDto
     */
    'metadata': object;
}

export const DraftOriginDtoTypeEnum = {
    Email: 'email',
    Slack: 'slack',
    FreeText: 'free_text'
} as const;

export type DraftOriginDtoTypeEnum = typeof DraftOriginDtoTypeEnum[keyof typeof DraftOriginDtoTypeEnum];

/**
 * 
 * @export
 * @interface EnrichedRecentActivity
 */
export interface EnrichedRecentActivity {
    /**
     * 
     * @type {RecentActivityData}
     * @memberof EnrichedRecentActivity
     */
    'data': RecentActivityData;
    /**
     * 
     * @type {boolean}
     * @memberof EnrichedRecentActivity
     */
    'seen': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EnrichedRecentActivity
     */
    'read': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'taskId': string;
    /**
     * 
     * @type {User}
     * @memberof EnrichedRecentActivity
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'type': EnrichedRecentActivityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'origin': EnrichedRecentActivityOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedRecentActivity
     */
    'flag': EnrichedRecentActivityFlagEnum;
}

export const EnrichedRecentActivityTypeEnum = {
    TaskAcknowledged: 'task_acknowledged',
    Link: 'link',
    TaskTitleChanged: 'task_title_changed',
    TaskDescriptionChanged: 'task_description_changed',
    TaskStatusChanged: 'task_status_changed',
    TicketStatusChanged: 'ticket_status_changed',
    TaskPostponed: 'task_postponed',
    TicketAdded: 'ticket_added',
    TicketPostponed: 'ticket_postponed',
    ContributorsAdded: 'contributors_added',
    ContributorsRemoved: 'contributors_removed',
    OwnerSet: 'owner_set',
    OwnerChanged: 'owner_changed',
    OwnerRemoved: 'owner_removed',
    GeneratedInsight: 'generated_insight',
    DiscussionAdded: 'discussion_added'
} as const;

export type EnrichedRecentActivityTypeEnum = typeof EnrichedRecentActivityTypeEnum[keyof typeof EnrichedRecentActivityTypeEnum];
export const EnrichedRecentActivityOriginEnum = {
    Null: 'null',
    Empty: '',
    ManuallyAdded: 'manually_added',
    Slack: 'slack',
    Email: 'email',
    System: 'system',
    Admin: 'admin'
} as const;

export type EnrichedRecentActivityOriginEnum = typeof EnrichedRecentActivityOriginEnum[keyof typeof EnrichedRecentActivityOriginEnum];
export const EnrichedRecentActivityFlagEnum = {
    Null: 'null',
    Empty: '',
    Highlight: 'highlight',
    Risk: 'risk'
} as const;

export type EnrichedRecentActivityFlagEnum = typeof EnrichedRecentActivityFlagEnum[keyof typeof EnrichedRecentActivityFlagEnum];

/**
 * 
 * @export
 * @interface EnrichedTask
 */
export interface EnrichedTask {
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'status': EnrichedTaskStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof EnrichedTask
     */
    'unseenRecentActivitiesCount': number;
    /**
     * 
     * @type {Array<EnrichedRecentActivity>}
     * @memberof EnrichedTask
     */
    'recentActivityLog': Array<EnrichedRecentActivity>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnrichedTask
     */
    'collateralsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof EnrichedTask
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'creatorId': string;
    /**
     * 
     * @type {User}
     * @memberof EnrichedTask
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'description': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof EnrichedTask
     */
    'contributors'?: Array<User>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnrichedTask
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<Collateral>}
     * @memberof EnrichedTask
     */
    'collaterals'?: Array<Collateral>;
    /**
     * 
     * @type {string}
     * @memberof EnrichedTask
     */
    'deletedAt'?: string;
}

export const EnrichedTaskStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type EnrichedTaskStatusEnum = typeof EnrichedTaskStatusEnum[keyof typeof EnrichedTaskStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EventSource = {
    Slackbot: 'slackbot'
} as const;

export type EventSource = typeof EventSource[keyof typeof EventSource];


/**
 * 
 * @export
 * @interface ForbiddenTicketCollateral
 */
export interface ForbiddenTicketCollateral {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenTicketCollateral
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof ForbiddenTicketCollateral
     */
    'spaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForbiddenTicketCollateral
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GenerateRedirectDto
 */
export interface GenerateRedirectDto {
    /**
     * 
     * @type {string}
     * @memberof GenerateRedirectDto
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateRedirectDto
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateRedirectDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface GeneratedInsight
 */
export interface GeneratedInsight {
    /**
     * 
     * @type {string}
     * @memberof GeneratedInsight
     */
    'discussionMessageId': string;
    /**
     * 
     * @type {string}
     * @memberof GeneratedInsight
     */
    'insight': string;
    /**
     * 
     * @type {string}
     * @memberof GeneratedInsight
     */
    'collateralId'?: string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck200Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200ResponseInfoValue
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'info'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'error'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
     * @memberof HealthControllerCheck503Response
     */
    'details'?: { [key: string]: HealthControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface IAnalyticsEvent
 */
export interface IAnalyticsEvent {
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'orgId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsEvent
     */
    'timestamp'?: string;
    /**
     * 
     * @type {EventSource}
     * @memberof IAnalyticsEvent
     */
    'eventSource'?: EventSource;
    /**
     * 
     * @type {object}
     * @memberof IAnalyticsEvent
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface IAnalyticsIdetitiy
 */
export interface IAnalyticsIdetitiy {
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'orgId': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IAnalyticsIdetitiy
     */
    'createdAt': string;
    /**
     * 
     * @type {object}
     * @memberof IAnalyticsIdetitiy
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface ImportFreeTextDto
 */
export interface ImportFreeTextDto {
    /**
     * 
     * @type {string}
     * @memberof ImportFreeTextDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ImportRefreshJob
 */
export interface ImportRefreshJob {
    /**
     * 
     * @type {Organization}
     * @memberof ImportRefreshJob
     */
    'organization': Organization;
}
/**
 * 
 * @export
 * @interface ImportSlackDto
 */
export interface ImportSlackDto {
    /**
     * 
     * @type {string}
     * @memberof ImportSlackDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ImportSlackDto
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ImportTaskResponse
 */
export interface ImportTaskResponse {
    /**
     * 
     * @type {Array<TaskDraft>}
     * @memberof ImportTaskResponse
     */
    'drafts': Array<TaskDraft>;
}
/**
 * 
 * @export
 * @interface ImportTaskUser
 */
export interface ImportTaskUser {
    /**
     * 
     * @type {string}
     * @memberof ImportTaskUser
     */
    'text'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof ImportTaskUser
     */
    'baseUsers'?: Array<User>;
}
/**
 * 
 * @export
 * @interface InsightCreatedNotification
 */
export interface InsightCreatedNotification {
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'changerId': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'insight': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'recentActivityId': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'flag'?: string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'discussionMessageId': string;
    /**
     * 
     * @type {string}
     * @memberof InsightCreatedNotification
     */
    'collateralId': string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'group': string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'provider': string;
}
/**
 * 
 * @export
 * @interface LinkCollateral
 */
export interface LinkCollateral {
    /**
     * 
     * @type {string}
     * @memberof LinkCollateral
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof LinkCollateral
     */
    'group': LinkCollateralGroupEnum;
}

export const LinkCollateralGroupEnum = {
    Document: 'document',
    Presentation: 'presentation',
    Spreadsheet: 'spreadsheet',
    NonSpecific: 'non_specific',
    Unknown: 'unknown'
} as const;

export type LinkCollateralGroupEnum = typeof LinkCollateralGroupEnum[keyof typeof LinkCollateralGroupEnum];

/**
 * 
 * @export
 * @interface MarkAllAsAll
 */
export interface MarkAllAsAll {
    /**
     * 
     * @type {string}
     * @memberof MarkAllAsAll
     */
    'untilTime': string;
}
/**
 * 
 * @export
 * @interface MessengerMessage
 */
export interface MessengerMessage {
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'userEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'channelId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessengerMessage
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof MessengerMessage
     */
    'blocks'?: object;
}
/**
 * 
 * @export
 * @interface MicroUser
 */
export interface MicroUser {
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'imageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicroUser
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'domain': string;
    /**
     * 
     * @type {OrganizationSettings}
     * @memberof Organization
     */
    'settings': OrganizationSettings;
    /**
     * 
     * @type {Array<User>}
     * @memberof Organization
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationSettings
     */
    'organization': Organization;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettings
     */
    'organizationId': string;
    /**
     * 
     * @type {OrganizationSettingsDto}
     * @memberof OrganizationSettings
     */
    'settings': OrganizationSettingsDto;
}
/**
 * 
 * @export
 * @interface OrganizationSettingsDto
 */
export interface OrganizationSettingsDto {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'slackTeamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSettingsDto
     */
    'preferredMessenger'?: string;
}
/**
 * 
 * @export
 * @interface OwnerChanged
 */
export interface OwnerChanged {
    /**
     * 
     * @type {MicroUser}
     * @memberof OwnerChanged
     */
    'previousOwner'?: MicroUser;
    /**
     * 
     * @type {MicroUser}
     * @memberof OwnerChanged
     */
    'currentOwner'?: MicroUser;
}
/**
 * 
 * @export
 * @interface PushNotificationDto
 */
export interface PushNotificationDto {
    /**
     * 
     * @type {PushNotificationDtoNotificationData}
     * @memberof PushNotificationDto
     */
    'notificationData': PushNotificationDtoNotificationData;
    /**
     * 
     * @type {string}
     * @memberof PushNotificationDto
     */
    'notifiedUserId': string;
    /**
     * 
     * @type {string}
     * @memberof PushNotificationDto
     */
    'type': PushNotificationDtoTypeEnum;
}

export const PushNotificationDtoTypeEnum = {
    TaskStatusChanged: 'task_status_changed',
    TaskDueDateChanged: 'task_due_date_changed',
    TaskDeclined: 'task_declined',
    InsightCreated: 'insight_created',
    TaskChanged: 'task_changed',
    TaskOwnerChanged: 'task_owner_changed',
    DiscussionAdded: 'discussion_added'
} as const;

export type PushNotificationDtoTypeEnum = typeof PushNotificationDtoTypeEnum[keyof typeof PushNotificationDtoTypeEnum];

/**
 * @type PushNotificationDtoNotificationData
 * @export
 */
export type PushNotificationDtoNotificationData = InsightCreatedNotification | TaskDueDateChangeNotification | TaskStatusChangeNotification;

/**
 * 
 * @export
 * @interface RecentActivity
 */
export interface RecentActivity {
    /**
     * 
     * @type {RecentActivityData}
     * @memberof RecentActivity
     */
    'data': RecentActivityData;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'id': string;
    /**
     * 
     * @type {Task}
     * @memberof RecentActivity
     */
    'task': Task;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'taskId': string;
    /**
     * 
     * @type {User}
     * @memberof RecentActivity
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'type': RecentActivityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'origin': RecentActivityOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RecentActivity
     */
    'flag': RecentActivityFlagEnum;
}

export const RecentActivityTypeEnum = {
    TaskAcknowledged: 'task_acknowledged',
    Link: 'link',
    TaskTitleChanged: 'task_title_changed',
    TaskDescriptionChanged: 'task_description_changed',
    TaskStatusChanged: 'task_status_changed',
    TicketStatusChanged: 'ticket_status_changed',
    TaskPostponed: 'task_postponed',
    TicketAdded: 'ticket_added',
    TicketPostponed: 'ticket_postponed',
    ContributorsAdded: 'contributors_added',
    ContributorsRemoved: 'contributors_removed',
    OwnerSet: 'owner_set',
    OwnerChanged: 'owner_changed',
    OwnerRemoved: 'owner_removed',
    GeneratedInsight: 'generated_insight',
    DiscussionAdded: 'discussion_added'
} as const;

export type RecentActivityTypeEnum = typeof RecentActivityTypeEnum[keyof typeof RecentActivityTypeEnum];
export const RecentActivityOriginEnum = {
    Null: 'null',
    Empty: '',
    ManuallyAdded: 'manually_added',
    Slack: 'slack',
    Email: 'email',
    System: 'system',
    Admin: 'admin'
} as const;

export type RecentActivityOriginEnum = typeof RecentActivityOriginEnum[keyof typeof RecentActivityOriginEnum];
export const RecentActivityFlagEnum = {
    Null: 'null',
    Empty: '',
    Highlight: 'highlight',
    Risk: 'risk'
} as const;

export type RecentActivityFlagEnum = typeof RecentActivityFlagEnum[keyof typeof RecentActivityFlagEnum];

/**
 * @type RecentActivityData
 * @export
 */
export type RecentActivityData = ContributorsChanged | DiscussionAdded | GeneratedInsight | Link | OwnerChanged | TaskAcknowledged | TaskDescriptionChanged | TaskPostponement | TaskStatusChange | TaskTitleChanged | Ticket | TicketPostponement | TicketStatusChange;

/**
 * 
 * @export
 * @interface ReportBugDto
 */
export interface ReportBugDto {
    /**
     * 
     * @type {string}
     * @memberof ReportBugDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof ReportBugDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SlackAddCollateralDto
 */
export interface SlackAddCollateralDto {
    /**
     * 
     * @type {string}
     * @memberof SlackAddCollateralDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SlackAddCollateralDto
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof SlackAddCollateralDto
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SlackAddCollateralDto
     */
    'creatorComment'?: string;
}
/**
 * 
 * @export
 * @interface SlackGetTasksDto
 */
export interface SlackGetTasksDto {
    /**
     * 
     * @type {string}
     * @memberof SlackGetTasksDto
     */
    'userEmail': string;
}
/**
 * 
 * @export
 * @interface SlackUpdateTaskDto
 */
export interface SlackUpdateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'status'?: SlackUpdateTaskDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlackUpdateTaskDto
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackUpdateTaskDto
     */
    'id'?: string;
}

export const SlackUpdateTaskDtoStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type SlackUpdateTaskDtoStatusEnum = typeof SlackUpdateTaskDtoStatusEnum[keyof typeof SlackUpdateTaskDtoStatusEnum];

/**
 * 
 * @export
 * @interface SlackUserDto
 */
export interface SlackUserDto {
    /**
     * 
     * @type {string}
     * @memberof SlackUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SlackUserDto
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof SlackUserDto
     */
    'profileImage': string;
    /**
     * 
     * @type {number}
     * @memberof SlackUserDto
     */
    'timezoneOffset': number;
}
/**
 * 
 * @export
 * @interface SlimPersonalizedTask
 */
export interface SlimPersonalizedTask {
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'status': SlimPersonalizedTaskStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SlimPersonalizedTask
     */
    'unseenRecentActivitiesCount': number;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof SlimPersonalizedTask
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'creatorId': string;
    /**
     * 
     * @type {User}
     * @memberof SlimPersonalizedTask
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'description': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof SlimPersonalizedTask
     */
    'contributors'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlimPersonalizedTask
     */
    'deletedAt'?: string;
}

export const SlimPersonalizedTaskStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type SlimPersonalizedTaskStatusEnum = typeof SlimPersonalizedTaskStatusEnum[keyof typeof SlimPersonalizedTaskStatusEnum];

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'status': TaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof Task
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'creatorId': string;
    /**
     * 
     * @type {User}
     * @memberof Task
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Task
     */
    'contributors'?: Array<User>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Task
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<Collateral>}
     * @memberof Task
     */
    'collaterals'?: Array<Collateral>;
    /**
     * 
     * @type {Array<DiscussionMessage>}
     * @memberof Task
     */
    'discussionMessages'?: Array<DiscussionMessage>;
    /**
     * 
     * @type {Array<RecentActivity>}
     * @memberof Task
     */
    'recentActivityLog'?: Array<RecentActivity>;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'deletedAt'?: string;
}

export const TaskStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];

/**
 * 
 * @export
 * @interface TaskAcknowledged
 */
export interface TaskAcknowledged {
    /**
     * 
     * @type {boolean}
     * @memberof TaskAcknowledged
     */
    'acknowledged': boolean;
}
/**
 * 
 * @export
 * @interface TaskChangeNotification
 */
export interface TaskChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskChangeNotification
     */
    'changerId': string;
}
/**
 * 
 * @export
 * @interface TaskDeclinedNotification
 */
export interface TaskDeclinedNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskDeclinedNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDeclinedNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDeclinedNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDeclinedNotification
     */
    'changerId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDeclinedNotification
     */
    'declinerId': string;
}
/**
 * 
 * @export
 * @interface TaskDescriptionChanged
 */
export interface TaskDescriptionChanged {
    /**
     * 
     * @type {string}
     * @memberof TaskDescriptionChanged
     */
    'previousDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDescriptionChanged
     */
    'currentDescription': string;
    /**
     * 
     * @type {number}
     * @memberof TaskDescriptionChanged
     */
    'changeTime': number;
}
/**
 * 
 * @export
 * @interface TaskDraft
 */
export interface TaskDraft {
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof TaskDraft
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'creatorId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'description'?: string;
    /**
     * 
     * @type {User}
     * @memberof TaskDraft
     */
    'assignee'?: User;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'assigneeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'assigneeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'dueDateText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'updatedAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskDraft
     */
    'convertedToTask': boolean;
    /**
     * 
     * @type {DraftOriginDto}
     * @memberof TaskDraft
     */
    'origin'?: DraftOriginDto;
    /**
     * 
     * @type {User}
     * @memberof TaskDraft
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDraft
     */
    'ownerText'?: string;
    /**
     * 
     * @type {Array<ImportTaskUser>}
     * @memberof TaskDraft
     */
    'possibleContributors'?: Array<ImportTaskUser>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDraft
     */
    'contributorIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaskDueDateChangeNotification
 */
export interface TaskDueDateChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskDueDateChangeNotification
     */
    'changerId': string;
    /**
     * 
     * @type {object}
     * @memberof TaskDueDateChangeNotification
     */
    'previousDueDate'?: object;
    /**
     * 
     * @type {object}
     * @memberof TaskDueDateChangeNotification
     */
    'currentDueDate'?: object;
}
/**
 * 
 * @export
 * @interface TaskMessageDto
 */
export interface TaskMessageDto {
    /**
     * 
     * @type {Task}
     * @memberof TaskMessageDto
     */
    'task': Task;
    /**
     * 
     * @type {User}
     * @memberof TaskMessageDto
     */
    'user': User;
    /**
     * 
     * @type {boolean}
     * @memberof TaskMessageDto
     */
    'isCreator'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskMessageDto
     */
    'isOwner'?: boolean;
}
/**
 * 
 * @export
 * @interface TaskOwnerChangeNotification
 */
export interface TaskOwnerChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'changerId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'changeTrigger'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'previousOwnerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskOwnerChangeNotification
     */
    'currentOwnerId'?: string;
}
/**
 * 
 * @export
 * @interface TaskPostponement
 */
export interface TaskPostponement {
    /**
     * 
     * @type {string}
     * @memberof TaskPostponement
     */
    'previousDueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskPostponement
     */
    'currentDueDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskPostponement
     */
    'changeTime': number;
}
/**
 * 
 * @export
 * @interface TaskResponseDto
 */
export interface TaskResponseDto {
    /**
     * 
     * @type {TaskResponseDtoTask}
     * @memberof TaskResponseDto
     */
    'task': TaskResponseDtoTask | null;
}
/**
 * 
 * @export
 * @interface TaskResponseDtoTask
 */
export interface TaskResponseDtoTask {
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'status': TaskResponseDtoTaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof TaskResponseDtoTask
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'creatorId': string;
    /**
     * 
     * @type {User}
     * @memberof TaskResponseDtoTask
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'ownerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'description': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof TaskResponseDtoTask
     */
    'contributors'?: Array<User>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskResponseDtoTask
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'dueDate'?: string;
    /**
     * 
     * @type {Array<Collateral>}
     * @memberof TaskResponseDtoTask
     */
    'collaterals'?: Array<Collateral>;
    /**
     * 
     * @type {Array<DiscussionMessage>}
     * @memberof TaskResponseDtoTask
     */
    'discussionMessages'?: Array<DiscussionMessage>;
    /**
     * 
     * @type {Array<RecentActivity>}
     * @memberof TaskResponseDtoTask
     */
    'recentActivityLog'?: Array<RecentActivity>;
    /**
     * 
     * @type {string}
     * @memberof TaskResponseDtoTask
     */
    'deletedAt'?: string;
}

export const TaskResponseDtoTaskStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type TaskResponseDtoTaskStatusEnum = typeof TaskResponseDtoTaskStatusEnum[keyof typeof TaskResponseDtoTaskStatusEnum];

/**
 * 
 * @export
 * @interface TaskStatusChange
 */
export interface TaskStatusChange {
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChange
     */
    'previousStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChange
     */
    'currentStatus': string;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusChange
     */
    'changeTime': number;
}
/**
 * 
 * @export
 * @interface TaskStatusChangeNotification
 */
export interface TaskStatusChangeNotification {
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'taskTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'taskDescription': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'changerId': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'changeTrigger'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'previousStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusChangeNotification
     */
    'currentStatus': string;
}
/**
 * 
 * @export
 * @interface TaskTitleChanged
 */
export interface TaskTitleChanged {
    /**
     * 
     * @type {string}
     * @memberof TaskTitleChanged
     */
    'previousTitle': string;
    /**
     * 
     * @type {string}
     * @memberof TaskTitleChanged
     */
    'currentTitle': string;
    /**
     * 
     * @type {number}
     * @memberof TaskTitleChanged
     */
    'changeTime': number;
}
/**
 * 
 * @export
 * @interface TasksResponseDto
 */
export interface TasksResponseDto {
    /**
     * 
     * @type {Array<Task>}
     * @memberof TasksResponseDto
     */
    'tasks': Array<Task>;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'collateralId': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'provider': string;
}
/**
 * 
 * @export
 * @interface TicketCollateral
 */
export interface TicketCollateral {
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'spaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketCollateral
     */
    'providerAssigneesEmails'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'status'?: TicketCollateralStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'providerStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketCollateral
     */
    'updatedAt'?: string;
}

export const TicketCollateralStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type TicketCollateralStatusEnum = typeof TicketCollateralStatusEnum[keyof typeof TicketCollateralStatusEnum];

/**
 * 
 * @export
 * @interface TicketPostponement
 */
export interface TicketPostponement {
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'previousDueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'currentDueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketPostponement
     */
    'collateralId': string;
}
/**
 * 
 * @export
 * @interface TicketStatusChange
 */
export interface TicketStatusChange {
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'previousStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'currentStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TicketStatusChange
     */
    'collateralId': string;
}
/**
 * 
 * @export
 * @interface UpdateAndConvertDraftResponseDto
 */
export interface UpdateAndConvertDraftResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAndConvertDraftResponseDto
     */
    'ok': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateAndConvertDraftResponseDto
     */
    'error'?: string;
    /**
     * 
     * @type {Task}
     * @memberof UpdateAndConvertDraftResponseDto
     */
    'task'?: Task;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationDto
 */
export interface UpdateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface UpdateSettingsDto
 */
export interface UpdateSettingsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSettingsDto
     */
    'teamDomains': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'teamDisplayName': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSettingsDto
     */
    'teamLogo': string;
}
/**
 * 
 * @export
 * @interface UpdateTaskDraftDto
 */
export interface UpdateTaskDraftDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'assigneeText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'ownerText'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'dueDateText'?: string;
    /**
     * 
     * @type {DraftOriginDto}
     * @memberof UpdateTaskDraftDto
     */
    'origin'?: DraftOriginDto;
    /**
     * 
     * @type {Array<ImportTaskUser>}
     * @memberof UpdateTaskDraftDto
     */
    'possibleContributors'?: Array<ImportTaskUser>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateTaskDraftDto
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDraftDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UpdateTaskDto
 */
export interface UpdateTaskDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'status'?: UpdateTaskDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateTaskDto
     */
    'contributorsIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskDto
     */
    'dueDate'?: string;
}

export const UpdateTaskDtoStatusEnum = {
    NotStarted: 'not_started',
    Waiting: 'waiting',
    OnHold: 'on_hold',
    InProgress: 'in_progress',
    Done: 'done'
} as const;

export type UpdateTaskDtoStatusEnum = typeof UpdateTaskDtoStatusEnum[keyof typeof UpdateTaskDtoStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileImage': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'externalAuthId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UsersImportDto
 */
export interface UsersImportDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersImportDto
     */
    'teamDomains': Array<string>;
    /**
     * 
     * @type {Array<SlackUserDto>}
     * @memberof UsersImportDto
     */
    'users': Array<SlackUserDto>;
}

/**
 * AppVersionsApi - axios parameter creator
 * @export
 */
export const AppVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appVersionsControllerGetAppVersions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app-versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppVersionsApi - functional programming interface
 * @export
 */
export const AppVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appVersionsControllerGetAppVersions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appVersionsControllerGetAppVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppVersionsApi - factory interface
 * @export
 */
export const AppVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppVersionsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appVersionsControllerGetAppVersions(options?: any): AxiosPromise<object> {
            return localVarFp.appVersionsControllerGetAppVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppVersionsApi - object-oriented interface
 * @export
 * @class AppVersionsApi
 * @extends {BaseAPI}
 */
export class AppVersionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    public appVersionsControllerGetAppVersions(options?: AxiosRequestConfig) {
        return AppVersionsApiFp(this.configuration).appVersionsControllerGetAppVersions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BugReportingApi - axios parameter creator
 * @export
 */
export const BugReportingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ReportBugDto} reportBugDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportingControllerReportBug: async (reportBugDto: ReportBugDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportBugDto' is not null or undefined
            assertParamExists('bugReportingControllerReportBug', 'reportBugDto', reportBugDto)
            const localVarPath = `/bug-reporting/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportBugDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BugReportingApi - functional programming interface
 * @export
 */
export const BugReportingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BugReportingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ReportBugDto} reportBugDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bugReportingControllerReportBug(reportBugDto: ReportBugDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bugReportingControllerReportBug(reportBugDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BugReportingApi - factory interface
 * @export
 */
export const BugReportingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BugReportingApiFp(configuration)
    return {
        /**
         * 
         * @param {ReportBugDto} reportBugDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bugReportingControllerReportBug(reportBugDto: ReportBugDto, options?: any): AxiosPromise<void> {
            return localVarFp.bugReportingControllerReportBug(reportBugDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BugReportingApi - object-oriented interface
 * @export
 * @class BugReportingApi
 * @extends {BaseAPI}
 */
export class BugReportingApi extends BaseAPI {
    /**
     * 
     * @param {ReportBugDto} reportBugDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugReportingApi
     */
    public bugReportingControllerReportBug(reportBugDto: ReportBugDto, options?: AxiosRequestConfig) {
        return BugReportingApiFp(this.configuration).bugReportingControllerReportBug(reportBugDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollateralsApi - axios parameter creator
 * @export
 */
export const CollateralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddCollateralDto} addCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collateralsControllerAddCollateral: async (addCollateralDto: AddCollateralDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCollateralDto' is not null or undefined
            assertParamExists('collateralsControllerAddCollateral', 'addCollateralDto', addCollateralDto)
            const localVarPath = `/collaterals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCollateralDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [loadTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collateralsControllerGetCollateral: async (id: string, loadTask?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('collateralsControllerGetCollateral', 'id', id)
            const localVarPath = `/collaterals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (loadTask !== undefined) {
                localVarQueryParameter['loadTask'] = loadTask;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collateralsControllerLoadActivity: async (taskId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('collateralsControllerLoadActivity', 'taskId', taskId)
            const localVarPath = `/collaterals/task/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollateralsApi - functional programming interface
 * @export
 */
export const CollateralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollateralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddCollateralDto} addCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collateralsControllerAddCollateral(addCollateralDto: AddCollateralDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collateralsControllerAddCollateral(addCollateralDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [loadTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collateralsControllerGetCollateral(id: string, loadTask?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collateral>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collateralsControllerGetCollateral(id, loadTask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collateralsControllerLoadActivity(taskId: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Collateral>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collateralsControllerLoadActivity(taskId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollateralsApi - factory interface
 * @export
 */
export const CollateralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollateralsApiFp(configuration)
    return {
        /**
         * 
         * @param {AddCollateralDto} addCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collateralsControllerAddCollateral(addCollateralDto: AddCollateralDto, options?: any): AxiosPromise<string> {
            return localVarFp.collateralsControllerAddCollateral(addCollateralDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [loadTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collateralsControllerGetCollateral(id: string, loadTask?: boolean, options?: any): AxiosPromise<Collateral> {
            return localVarFp.collateralsControllerGetCollateral(id, loadTask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collateralsControllerLoadActivity(taskId: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<Collateral>> {
            return localVarFp.collateralsControllerLoadActivity(taskId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollateralsApi - object-oriented interface
 * @export
 * @class CollateralsApi
 * @extends {BaseAPI}
 */
export class CollateralsApi extends BaseAPI {
    /**
     * 
     * @param {AddCollateralDto} addCollateralDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollateralsApi
     */
    public collateralsControllerAddCollateral(addCollateralDto: AddCollateralDto, options?: AxiosRequestConfig) {
        return CollateralsApiFp(this.configuration).collateralsControllerAddCollateral(addCollateralDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [loadTask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollateralsApi
     */
    public collateralsControllerGetCollateral(id: string, loadTask?: boolean, options?: AxiosRequestConfig) {
        return CollateralsApiFp(this.configuration).collateralsControllerGetCollateral(id, loadTask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollateralsApi
     */
    public collateralsControllerLoadActivity(taskId: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return CollateralsApiFp(this.configuration).collateralsControllerLoadActivity(taskId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appControllerGetHello(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: any): AxiosPromise<void> {
            return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: any): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthControllerCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscussionsApi - axios parameter creator
 * @export
 */
export const DiscussionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {boolean} [loadTask] 
         * @param {boolean} [loadCollateral] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionsControllerFindOne: async (id: string, loadTask?: boolean, loadCollateral?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discussionsControllerFindOne', 'id', id)
            const localVarPath = `/discussions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (loadTask !== undefined) {
                localVarQueryParameter['loadTask'] = loadTask;
            }

            if (loadCollateral !== undefined) {
                localVarQueryParameter['loadCollateral'] = loadCollateral;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} collateralId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionsControllerLoadDiscussionsByCollateral: async (collateralId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collateralId' is not null or undefined
            assertParamExists('discussionsControllerLoadDiscussionsByCollateral', 'collateralId', collateralId)
            const localVarPath = `/discussions/collateral/{collateralId}`
                .replace(`{${"collateralId"}}`, encodeURIComponent(String(collateralId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionsControllerLoadDiscussionsByTask: async (taskId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('discussionsControllerLoadDiscussionsByTask', 'taskId', taskId)
            const localVarPath = `/discussions/task/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscussionsApi - functional programming interface
 * @export
 */
export const DiscussionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscussionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {boolean} [loadTask] 
         * @param {boolean} [loadCollateral] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discussionsControllerFindOne(id: string, loadTask?: boolean, loadCollateral?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscussionMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discussionsControllerFindOne(id, loadTask, loadCollateral, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} collateralId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discussionsControllerLoadDiscussionsByCollateral(collateralId: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscussionMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discussionsControllerLoadDiscussionsByCollateral(collateralId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discussionsControllerLoadDiscussionsByTask(taskId: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscussionMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discussionsControllerLoadDiscussionsByTask(taskId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscussionsApi - factory interface
 * @export
 */
export const DiscussionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscussionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {boolean} [loadTask] 
         * @param {boolean} [loadCollateral] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionsControllerFindOne(id: string, loadTask?: boolean, loadCollateral?: boolean, options?: any): AxiosPromise<DiscussionMessage> {
            return localVarFp.discussionsControllerFindOne(id, loadTask, loadCollateral, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} collateralId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionsControllerLoadDiscussionsByCollateral(collateralId: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<DiscussionMessage>> {
            return localVarFp.discussionsControllerLoadDiscussionsByCollateral(collateralId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionsControllerLoadDiscussionsByTask(taskId: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<DiscussionMessage>> {
            return localVarFp.discussionsControllerLoadDiscussionsByTask(taskId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscussionsApi - object-oriented interface
 * @export
 * @class DiscussionsApi
 * @extends {BaseAPI}
 */
export class DiscussionsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {boolean} [loadTask] 
     * @param {boolean} [loadCollateral] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscussionsApi
     */
    public discussionsControllerFindOne(id: string, loadTask?: boolean, loadCollateral?: boolean, options?: AxiosRequestConfig) {
        return DiscussionsApiFp(this.configuration).discussionsControllerFindOne(id, loadTask, loadCollateral, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} collateralId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscussionsApi
     */
    public discussionsControllerLoadDiscussionsByCollateral(collateralId: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DiscussionsApiFp(this.configuration).discussionsControllerLoadDiscussionsByCollateral(collateralId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscussionsApi
     */
    public discussionsControllerLoadDiscussionsByTask(taskId: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DiscussionsApiFp(this.configuration).discussionsControllerLoadDiscussionsByTask(taskId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ImportFreeTextDto} importFreeTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateDraftsFromFreeText: async (importFreeTextDto: ImportFreeTextDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importFreeTextDto' is not null or undefined
            assertParamExists('importTasksControllerCreateDraftsFromFreeText', 'importFreeTextDto', importFreeTextDto)
            const localVarPath = `/import-tasks/free-text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importFreeTextDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateTasksFromEmails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import-tasks/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ImportFreeTextDto} importFreeTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTasksControllerCreateDraftsFromFreeText(importFreeTextDto: ImportFreeTextDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTasksControllerCreateDraftsFromFreeText(importFreeTextDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTasksControllerCreateTasksFromEmails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTasksControllerCreateTasksFromEmails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * 
         * @param {ImportFreeTextDto} importFreeTextDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateDraftsFromFreeText(importFreeTextDto: ImportFreeTextDto, options?: any): AxiosPromise<ImportTaskResponse> {
            return localVarFp.importTasksControllerCreateDraftsFromFreeText(importFreeTextDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTasksControllerCreateTasksFromEmails(options?: any): AxiosPromise<void> {
            return localVarFp.importTasksControllerCreateTasksFromEmails(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * 
     * @param {ImportFreeTextDto} importFreeTextDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importTasksControllerCreateDraftsFromFreeText(importFreeTextDto: ImportFreeTextDto, options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).importTasksControllerCreateDraftsFromFreeText(importFreeTextDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importTasksControllerCreateTasksFromEmails(options?: AxiosRequestConfig) {
        return ImportApiFp(this.configuration).importTasksControllerCreateTasksFromEmails(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MobileApi - axios parameter creator
 * @export
 */
export const MobileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTaskWithCollateralsDto} createTaskWithCollateralsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerCreate: async (createTaskWithCollateralsDto: CreateTaskWithCollateralsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskWithCollateralsDto' is not null or undefined
            assertParamExists('mobileBffControllerCreate', 'createTaskWithCollateralsDto', createTaskWithCollateralsDto)
            const localVarPath = `/mobile/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskWithCollateralsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerFindOneOfMyTasks: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('mobileBffControllerFindOneOfMyTasks', 'taskId', taskId)
            const localVarPath = `/mobile/my-tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerMarkTasksAsAll: async (taskId: string, markAllAsAll: MarkAllAsAll, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('mobileBffControllerMarkTasksAsAll', 'taskId', taskId)
            // verify required parameter 'markAllAsAll' is not null or undefined
            assertParamExists('mobileBffControllerMarkTasksAsAll', 'markAllAsAll', markAllAsAll)
            const localVarPath = `/mobile/my-tasks/{taskId}/mark-as-all`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markAllAsAll, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerMyTasks: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mobile/my-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileApi - functional programming interface
 * @export
 */
export const MobileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTaskWithCollateralsDto} createTaskWithCollateralsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileBffControllerCreate(createTaskWithCollateralsDto: CreateTaskWithCollateralsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnrichedTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileBffControllerCreate(createTaskWithCollateralsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileBffControllerFindOneOfMyTasks(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnrichedTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileBffControllerFindOneOfMyTasks(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileBffControllerMarkTasksAsAll(taskId: string, markAllAsAll: MarkAllAsAll, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileBffControllerMarkTasksAsAll(taskId, markAllAsAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mobileBffControllerMyTasks(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlimPersonalizedTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mobileBffControllerMyTasks(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MobileApi - factory interface
 * @export
 */
export const MobileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTaskWithCollateralsDto} createTaskWithCollateralsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerCreate(createTaskWithCollateralsDto: CreateTaskWithCollateralsDto, options?: any): AxiosPromise<EnrichedTask> {
            return localVarFp.mobileBffControllerCreate(createTaskWithCollateralsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerFindOneOfMyTasks(taskId: string, options?: any): AxiosPromise<EnrichedTask> {
            return localVarFp.mobileBffControllerFindOneOfMyTasks(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerMarkTasksAsAll(taskId: string, markAllAsAll: MarkAllAsAll, options?: any): AxiosPromise<void> {
            return localVarFp.mobileBffControllerMarkTasksAsAll(taskId, markAllAsAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mobileBffControllerMyTasks(limit?: number, offset?: number, options?: any): AxiosPromise<Array<SlimPersonalizedTask>> {
            return localVarFp.mobileBffControllerMyTasks(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileApi - object-oriented interface
 * @export
 * @class MobileApi
 * @extends {BaseAPI}
 */
export class MobileApi extends BaseAPI {
    /**
     * 
     * @param {CreateTaskWithCollateralsDto} createTaskWithCollateralsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public mobileBffControllerCreate(createTaskWithCollateralsDto: CreateTaskWithCollateralsDto, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).mobileBffControllerCreate(createTaskWithCollateralsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public mobileBffControllerFindOneOfMyTasks(taskId: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).mobileBffControllerFindOneOfMyTasks(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {MarkAllAsAll} markAllAsAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public mobileBffControllerMarkTasksAsAll(taskId: string, markAllAsAll: MarkAllAsAll, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).mobileBffControllerMarkTasksAsAll(taskId, markAllAsAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public mobileBffControllerMyTasks(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).mobileBffControllerMyTasks(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OauthPublicApi - axios parameter creator
 * @export
 */
export const OauthPublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGenerateAuthRedirect: async (provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthPublicControllerGenerateAuthRedirect', 'provider', provider)
            const localVarPath = `/oauth-public/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGetAvailableProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-public/available-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGetUserProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-public/my-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerSendProviderInvite: async (provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthPublicControllerSendProviderInvite', 'provider', provider)
            const localVarPath = `/oauth-public/oauth-redirect-mail/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthPublicApi - functional programming interface
 * @export
 */
export const OauthPublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OauthPublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthPublicControllerGenerateAuthRedirect(provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthPublicControllerGenerateAuthRedirect(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthPublicControllerGetAvailableProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthPublicControllerGetAvailableProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthPublicControllerGetUserProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthPublicControllerGetUserProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthPublicControllerSendProviderInvite(provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthPublicControllerSendProviderInvite(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OauthPublicApi - factory interface
 * @export
 */
export const OauthPublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OauthPublicApiFp(configuration)
    return {
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGenerateAuthRedirect(provider: string, options?: any): AxiosPromise<string> {
            return localVarFp.oauthPublicControllerGenerateAuthRedirect(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGetAvailableProviders(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.oauthPublicControllerGetAvailableProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerGetUserProviders(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.oauthPublicControllerGetUserProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthPublicControllerSendProviderInvite(provider: string, options?: any): AxiosPromise<void> {
            return localVarFp.oauthPublicControllerSendProviderInvite(provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OauthPublicApi - object-oriented interface
 * @export
 * @class OauthPublicApi
 * @extends {BaseAPI}
 */
export class OauthPublicApi extends BaseAPI {
    /**
     * 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthPublicApi
     */
    public oauthPublicControllerGenerateAuthRedirect(provider: string, options?: AxiosRequestConfig) {
        return OauthPublicApiFp(this.configuration).oauthPublicControllerGenerateAuthRedirect(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthPublicApi
     */
    public oauthPublicControllerGetAvailableProviders(options?: AxiosRequestConfig) {
        return OauthPublicApiFp(this.configuration).oauthPublicControllerGetAvailableProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthPublicApi
     */
    public oauthPublicControllerGetUserProviders(options?: AxiosRequestConfig) {
        return OauthPublicApiFp(this.configuration).oauthPublicControllerGetUserProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthPublicApi
     */
    public oauthPublicControllerSendProviderInvite(provider: string, options?: AxiosRequestConfig) {
        return OauthPublicApiFp(this.configuration).oauthPublicControllerSendProviderInvite(provider, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationSettingsApi - axios parameter creator
 * @export
 */
export const OrganizationSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerFindOne: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrganizationSettingsDto} organizationSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerUpdate: async (organizationSettingsDto: OrganizationSettingsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSettingsDto' is not null or undefined
            assertParamExists('organizationSettingsControllerUpdate', 'organizationSettingsDto', organizationSettingsDto)
            const localVarPath = `/organization-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationSettingsApi - functional programming interface
 * @export
 */
export const OrganizationSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSettingsControllerFindOne(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSettingsControllerFindOne(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrganizationSettingsDto} organizationSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSettingsControllerUpdate(organizationSettingsDto: OrganizationSettingsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSettingsControllerUpdate(organizationSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationSettingsApi - factory interface
 * @export
 */
export const OrganizationSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationSettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerFindOne(options?: any): AxiosPromise<OrganizationSettings> {
            return localVarFp.organizationSettingsControllerFindOne(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrganizationSettingsDto} organizationSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSettingsControllerUpdate(organizationSettingsDto: OrganizationSettingsDto, options?: any): AxiosPromise<OrganizationSettings> {
            return localVarFp.organizationSettingsControllerUpdate(organizationSettingsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationSettingsApi - object-oriented interface
 * @export
 * @class OrganizationSettingsApi
 * @extends {BaseAPI}
 */
export class OrganizationSettingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationSettingsApi
     */
    public organizationSettingsControllerFindOne(options?: AxiosRequestConfig) {
        return OrganizationSettingsApiFp(this.configuration).organizationSettingsControllerFindOne(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrganizationSettingsDto} organizationSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationSettingsApi
     */
    public organizationSettingsControllerUpdate(organizationSettingsDto: OrganizationSettingsDto, options?: AxiosRequestConfig) {
        return OrganizationSettingsApiFp(this.configuration).organizationSettingsControllerUpdate(organizationSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerCreate: async (createOrganizationDto: CreateOrganizationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationDto' is not null or undefined
            assertParamExists('organizationsControllerCreate', 'createOrganizationDto', createOrganizationDto)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerFindOne', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerRemove', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerUpdate: async (id: string, updateOrganizationDto: UpdateOrganizationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerUpdate', 'id', id)
            // verify required parameter 'updateOrganizationDto' is not null or undefined
            assertParamExists('organizationsControllerUpdate', 'updateOrganizationDto', updateOrganizationDto)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerCreate(createOrganizationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerUpdate(id: string, updateOrganizationDto: UpdateOrganizationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerUpdate(id, updateOrganizationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: any): AxiosPromise<Organization> {
            return localVarFp.organizationsControllerCreate(createOrganizationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindAll(options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.organizationsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.organizationsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerUpdate(id: string, updateOrganizationDto: UpdateOrganizationDto, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsControllerUpdate(id, updateOrganizationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrganizationDto} createOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerCreate(createOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerFindAll(options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateOrganizationDto} updateOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerUpdate(id: string, updateOrganizationDto: UpdateOrganizationDto, options?: AxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerUpdate(id, updateOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PushNotificationsApi - axios parameter creator
 * @export
 */
export const PushNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceTokenDto} deviceTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationsControllerCreateOrUpdate: async (deviceTokenDto: DeviceTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceTokenDto' is not null or undefined
            assertParamExists('pushNotificationsControllerCreateOrUpdate', 'deviceTokenDto', deviceTokenDto)
            const localVarPath = `/push-notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationsApi - functional programming interface
 * @export
 */
export const PushNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeviceTokenDto} deviceTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationsControllerCreateOrUpdate(deviceTokenDto: DeviceTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationsControllerCreateOrUpdate(deviceTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PushNotificationsApi - factory interface
 * @export
 */
export const PushNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushNotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {DeviceTokenDto} deviceTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationsControllerCreateOrUpdate(deviceTokenDto: DeviceTokenDto, options?: any): AxiosPromise<DeviceToken> {
            return localVarFp.pushNotificationsControllerCreateOrUpdate(deviceTokenDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushNotificationsApi - object-oriented interface
 * @export
 * @class PushNotificationsApi
 * @extends {BaseAPI}
 */
export class PushNotificationsApi extends BaseAPI {
    /**
     * 
     * @param {DeviceTokenDto} deviceTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public pushNotificationsControllerCreateOrUpdate(deviceTokenDto: DeviceTokenDto, options?: AxiosRequestConfig) {
        return PushNotificationsApiFp(this.configuration).pushNotificationsControllerCreateOrUpdate(deviceTokenDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecentActivityApi - axios parameter creator
 * @export
 */
export const RecentActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerCountUnseen: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recent-activity/unseen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerCountUnseenOnTask: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('recentActivityControllerCountUnseenOnTask', 'taskId', taskId)
            const localVarPath = `/recent-activity/{taskId}/unseen`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerLoadActivity: async (taskId: string, limit: number, offset: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('recentActivityControllerLoadActivity', 'taskId', taskId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('recentActivityControllerLoadActivity', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('recentActivityControllerLoadActivity', 'offset', offset)
            const localVarPath = `/recent-activity/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerMarkAllPersonalizedAsAll: async (markAllAsAll: MarkAllAsAll, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markAllAsAll' is not null or undefined
            assertParamExists('recentActivityControllerMarkAllPersonalizedAsAll', 'markAllAsAll', markAllAsAll)
            const localVarPath = `/recent-activity/mark-as-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markAllAsAll, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerMarkAllPersonalizedOnTaskAsAll: async (taskId: string, markAllAsAll: MarkAllAsAll, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('recentActivityControllerMarkAllPersonalizedOnTaskAsAll', 'taskId', taskId)
            // verify required parameter 'markAllAsAll' is not null or undefined
            assertParamExists('recentActivityControllerMarkAllPersonalizedOnTaskAsAll', 'markAllAsAll', markAllAsAll)
            const localVarPath = `/recent-activity/{taskId}/mark-as-all`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markAllAsAll, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecentActivityApi - functional programming interface
 * @export
 */
export const RecentActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecentActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentActivityControllerCountUnseen(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentActivityControllerCountUnseen(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentActivityControllerCountUnseenOnTask(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentActivityControllerCountUnseenOnTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentActivityControllerLoadActivity(taskId: string, limit: number, offset: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecentActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentActivityControllerLoadActivity(taskId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentActivityControllerMarkAllPersonalizedAsAll(markAllAsAll: MarkAllAsAll, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentActivityControllerMarkAllPersonalizedAsAll(markAllAsAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentActivityControllerMarkAllPersonalizedOnTaskAsAll(taskId: string, markAllAsAll: MarkAllAsAll, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentActivityControllerMarkAllPersonalizedOnTaskAsAll(taskId, markAllAsAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecentActivityApi - factory interface
 * @export
 */
export const RecentActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecentActivityApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerCountUnseen(options?: any): AxiosPromise<number> {
            return localVarFp.recentActivityControllerCountUnseen(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerCountUnseenOnTask(taskId: string, options?: any): AxiosPromise<number> {
            return localVarFp.recentActivityControllerCountUnseenOnTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerLoadActivity(taskId: string, limit: number, offset: number, options?: any): AxiosPromise<Array<RecentActivity>> {
            return localVarFp.recentActivityControllerLoadActivity(taskId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerMarkAllPersonalizedAsAll(markAllAsAll: MarkAllAsAll, options?: any): AxiosPromise<void> {
            return localVarFp.recentActivityControllerMarkAllPersonalizedAsAll(markAllAsAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {MarkAllAsAll} markAllAsAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentActivityControllerMarkAllPersonalizedOnTaskAsAll(taskId: string, markAllAsAll: MarkAllAsAll, options?: any): AxiosPromise<void> {
            return localVarFp.recentActivityControllerMarkAllPersonalizedOnTaskAsAll(taskId, markAllAsAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecentActivityApi - object-oriented interface
 * @export
 * @class RecentActivityApi
 * @extends {BaseAPI}
 */
export class RecentActivityApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentActivityApi
     */
    public recentActivityControllerCountUnseen(options?: AxiosRequestConfig) {
        return RecentActivityApiFp(this.configuration).recentActivityControllerCountUnseen(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentActivityApi
     */
    public recentActivityControllerCountUnseenOnTask(taskId: string, options?: AxiosRequestConfig) {
        return RecentActivityApiFp(this.configuration).recentActivityControllerCountUnseenOnTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentActivityApi
     */
    public recentActivityControllerLoadActivity(taskId: string, limit: number, offset: number, options?: AxiosRequestConfig) {
        return RecentActivityApiFp(this.configuration).recentActivityControllerLoadActivity(taskId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarkAllAsAll} markAllAsAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentActivityApi
     */
    public recentActivityControllerMarkAllPersonalizedAsAll(markAllAsAll: MarkAllAsAll, options?: AxiosRequestConfig) {
        return RecentActivityApiFp(this.configuration).recentActivityControllerMarkAllPersonalizedAsAll(markAllAsAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {MarkAllAsAll} markAllAsAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentActivityApi
     */
    public recentActivityControllerMarkAllPersonalizedOnTaskAsAll(taskId: string, markAllAsAll: MarkAllAsAll, options?: AxiosRequestConfig) {
        return RecentActivityApiFp(this.configuration).recentActivityControllerMarkAllPersonalizedOnTaskAsAll(taskId, markAllAsAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SlackbotApiApi - axios parameter creator
 * @export
 */
export const SlackbotApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AcknowledgeTaskDto} acknowledgeTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAcknowledgeTask: async (acknowledgeTaskDto: AcknowledgeTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acknowledgeTaskDto' is not null or undefined
            assertParamExists('slackbotApiControllerAcknowledgeTask', 'acknowledgeTaskDto', acknowledgeTaskDto)
            const localVarPath = `/slackbot-api/task/acknowledge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acknowledgeTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SlackAddCollateralDto} slackAddCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAddCollateral: async (slackAddCollateralDto: SlackAddCollateralDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slackAddCollateralDto' is not null or undefined
            assertParamExists('slackbotApiControllerAddCollateral', 'slackAddCollateralDto', slackAddCollateralDto)
            const localVarPath = `/slackbot-api/collaterals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackAddCollateralDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddDiscussionFromSlackDto} addDiscussionFromSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAddDiscussion: async (addDiscussionFromSlackDto: AddDiscussionFromSlackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addDiscussionFromSlackDto' is not null or undefined
            assertParamExists('slackbotApiControllerAddDiscussion', 'addDiscussionFromSlackDto', addDiscussionFromSlackDto)
            const localVarPath = `/slackbot-api/discussions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addDiscussionFromSlackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsersImportDto} usersImportDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreate: async (usersImportDto: UsersImportDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersImportDto' is not null or undefined
            assertParamExists('slackbotApiControllerCreate', 'usersImportDto', usersImportDto)
            const localVarPath = `/slackbot-api/import/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersImportDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportSlackDto} importSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreateTasksFromSlackMessage: async (importSlackDto: ImportSlackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importSlackDto' is not null or undefined
            assertParamExists('slackbotApiControllerCreateTasksFromSlackMessage', 'importSlackDto', importSlackDto)
            const localVarPath = `/slackbot-api/create-drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importSlackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateRedirectDto} generateRedirectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerGenerateOauthRedirect: async (generateRedirectDto: GenerateRedirectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateRedirectDto' is not null or undefined
            assertParamExists('slackbotApiControllerGenerateOauthRedirect', 'generateRedirectDto', generateRedirectDto)
            const localVarPath = `/slackbot-api/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateRedirectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SlackGetTasksDto} slackGetTasksDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerGetTasks: async (slackGetTasksDto: SlackGetTasksDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slackGetTasksDto' is not null or undefined
            assertParamExists('slackbotApiControllerGetTasks', 'slackGetTasksDto', slackGetTasksDto)
            const localVarPath = `/slackbot-api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackGetTasksDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerGetUserProviders: async (userId: string, orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('slackbotApiControllerGetUserProviders', 'userId', userId)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('slackbotApiControllerGetUserProviders', 'orgId', orgId)
            const localVarPath = `/slackbot-api/oauth/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdate: async (id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slackbotApiControllerUpdate', 'id', id)
            // verify required parameter 'slackUpdateTaskDto' is not null or undefined
            assertParamExists('slackbotApiControllerUpdate', 'slackUpdateTaskDto', slackUpdateTaskDto)
            const localVarPath = `/slackbot-api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackUpdateTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdateSettings: async (updateSettingsDto: UpdateSettingsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSettingsDto' is not null or undefined
            assertParamExists('slackbotApiControllerUpdateSettings', 'updateSettingsDto', updateSettingsDto)
            const localVarPath = `/slackbot-api/organization-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlackbotApiApi - functional programming interface
 * @export
 */
export const SlackbotApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlackbotApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AcknowledgeTaskDto} acknowledgeTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerAcknowledgeTask(acknowledgeTaskDto: AcknowledgeTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerAcknowledgeTask(acknowledgeTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SlackAddCollateralDto} slackAddCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerAddCollateral(slackAddCollateralDto: SlackAddCollateralDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerAddCollateral(slackAddCollateralDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AddDiscussionFromSlackDto} addDiscussionFromSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerAddDiscussion(addDiscussionFromSlackDto: AddDiscussionFromSlackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerAddDiscussion(addDiscussionFromSlackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UsersImportDto} usersImportDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerCreate(usersImportDto: UsersImportDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerCreate(usersImportDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportSlackDto} importSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto: ImportSlackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {GenerateRedirectDto} generateRedirectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerGenerateOauthRedirect(generateRedirectDto: GenerateRedirectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerGenerateOauthRedirect(generateRedirectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SlackGetTasksDto} slackGetTasksDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerGetTasks(slackGetTasksDto: SlackGetTasksDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerGetTasks(slackGetTasksDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerGetUserProviders(userId: string, orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerGetUserProviders(userId, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerUpdate(id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerUpdate(id, slackUpdateTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slackbotApiControllerUpdateSettings(updateSettingsDto: UpdateSettingsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slackbotApiControllerUpdateSettings(updateSettingsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SlackbotApiApi - factory interface
 * @export
 */
export const SlackbotApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlackbotApiApiFp(configuration)
    return {
        /**
         * 
         * @param {AcknowledgeTaskDto} acknowledgeTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAcknowledgeTask(acknowledgeTaskDto: AcknowledgeTaskDto, options?: any): AxiosPromise<TaskResponseDto> {
            return localVarFp.slackbotApiControllerAcknowledgeTask(acknowledgeTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SlackAddCollateralDto} slackAddCollateralDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAddCollateral(slackAddCollateralDto: SlackAddCollateralDto, options?: any): AxiosPromise<TaskResponseDto> {
            return localVarFp.slackbotApiControllerAddCollateral(slackAddCollateralDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddDiscussionFromSlackDto} addDiscussionFromSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerAddDiscussion(addDiscussionFromSlackDto: AddDiscussionFromSlackDto, options?: any): AxiosPromise<void> {
            return localVarFp.slackbotApiControllerAddDiscussion(addDiscussionFromSlackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsersImportDto} usersImportDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreate(usersImportDto: UsersImportDto, options?: any): AxiosPromise<void> {
            return localVarFp.slackbotApiControllerCreate(usersImportDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportSlackDto} importSlackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto: ImportSlackDto, options?: any): AxiosPromise<void> {
            return localVarFp.slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateRedirectDto} generateRedirectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerGenerateOauthRedirect(generateRedirectDto: GenerateRedirectDto, options?: any): AxiosPromise<string> {
            return localVarFp.slackbotApiControllerGenerateOauthRedirect(generateRedirectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SlackGetTasksDto} slackGetTasksDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerGetTasks(slackGetTasksDto: SlackGetTasksDto, options?: any): AxiosPromise<TasksResponseDto> {
            return localVarFp.slackbotApiControllerGetTasks(slackGetTasksDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerGetUserProviders(userId: string, orgId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.slackbotApiControllerGetUserProviders(userId, orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdate(id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options?: any): AxiosPromise<TaskResponseDto> {
            return localVarFp.slackbotApiControllerUpdate(id, slackUpdateTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateSettingsDto} updateSettingsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slackbotApiControllerUpdateSettings(updateSettingsDto: UpdateSettingsDto, options?: any): AxiosPromise<OrganizationSettings> {
            return localVarFp.slackbotApiControllerUpdateSettings(updateSettingsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlackbotApiApi - object-oriented interface
 * @export
 * @class SlackbotApiApi
 * @extends {BaseAPI}
 */
export class SlackbotApiApi extends BaseAPI {
    /**
     * 
     * @param {AcknowledgeTaskDto} acknowledgeTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerAcknowledgeTask(acknowledgeTaskDto: AcknowledgeTaskDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerAcknowledgeTask(acknowledgeTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SlackAddCollateralDto} slackAddCollateralDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerAddCollateral(slackAddCollateralDto: SlackAddCollateralDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerAddCollateral(slackAddCollateralDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddDiscussionFromSlackDto} addDiscussionFromSlackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerAddDiscussion(addDiscussionFromSlackDto: AddDiscussionFromSlackDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerAddDiscussion(addDiscussionFromSlackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersImportDto} usersImportDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerCreate(usersImportDto: UsersImportDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerCreate(usersImportDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportSlackDto} importSlackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto: ImportSlackDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerCreateTasksFromSlackMessage(importSlackDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateRedirectDto} generateRedirectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerGenerateOauthRedirect(generateRedirectDto: GenerateRedirectDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerGenerateOauthRedirect(generateRedirectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SlackGetTasksDto} slackGetTasksDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerGetTasks(slackGetTasksDto: SlackGetTasksDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerGetTasks(slackGetTasksDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerGetUserProviders(userId: string, orgId: string, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerGetUserProviders(userId, orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SlackUpdateTaskDto} slackUpdateTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerUpdate(id: string, slackUpdateTaskDto: SlackUpdateTaskDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerUpdate(id, slackUpdateTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateSettingsDto} updateSettingsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackbotApiApi
     */
    public slackbotApiControllerUpdateSettings(updateSettingsDto: UpdateSettingsDto, options?: AxiosRequestConfig) {
        return SlackbotApiApiFp(this.configuration).slackbotApiControllerUpdateSettings(updateSettingsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskDraftsApi - axios parameter creator
 * @export
 */
export const TaskDraftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConvertDraftsDto} convertDraftsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerConvertToTasks: async (convertDraftsDto: ConvertDraftsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'convertDraftsDto' is not null or undefined
            assertParamExists('taskDraftsControllerConvertToTasks', 'convertDraftsDto', convertDraftsDto)
            const localVarPath = `/task-drafts/convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(convertDraftsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTaskDraftDto} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreate: async (createTaskDraftDto: CreateTaskDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerCreate', 'createTaskDraftDto', createTaskDraftDto)
            const localVarPath = `/task-drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreateBulk: async (createTaskDraftDto: Array<CreateTaskDraftDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerCreateBulk', 'createTaskDraftDto', createTaskDraftDto)
            const localVarPath = `/task-drafts/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindDraftsByCreator: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task-drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskDraftsControllerFindOne', 'id', id)
            const localVarPath = `/task-drafts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskDraftsControllerRemove', 'id', id)
            const localVarPath = `/task-drafts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemoveBulk: async (deleteDraftsBulkDto: DeleteDraftsBulkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteDraftsBulkDto' is not null or undefined
            assertParamExists('taskDraftsControllerRemoveBulk', 'deleteDraftsBulkDto', deleteDraftsBulkDto)
            const localVarPath = `/task-drafts/delete-bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDraftsBulkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdate: async (id: string, updateTaskDraftDto: UpdateTaskDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskDraftsControllerUpdate', 'id', id)
            // verify required parameter 'updateTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerUpdate', 'updateTaskDraftDto', updateTaskDraftDto)
            const localVarPath = `/task-drafts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdateAndConverToTask: async (updateTaskDraftDto: UpdateTaskDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTaskDraftDto' is not null or undefined
            assertParamExists('taskDraftsControllerUpdateAndConverToTask', 'updateTaskDraftDto', updateTaskDraftDto)
            const localVarPath = `/task-drafts/update-and-convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskDraftsApi - functional programming interface
 * @export
 */
export const TaskDraftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskDraftsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConvertDraftsDto} convertDraftsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerConvertToTasks(convertDraftsDto: ConvertDraftsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConvertDraftsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerConvertToTasks(convertDraftsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTaskDraftDto} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerCreate(createTaskDraftDto: CreateTaskDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerCreate(createTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerCreateBulk(createTaskDraftDto: Array<CreateTaskDraftDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDraft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerCreateBulk(createTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerFindDraftsByCreator(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDraft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerFindDraftsByCreator(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerRemoveBulk(deleteDraftsBulkDto: DeleteDraftsBulkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerRemoveBulk(deleteDraftsBulkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerUpdate(id: string, updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerUpdate(id, updateTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAndConvertDraftResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskDraftsApi - factory interface
 * @export
 */
export const TaskDraftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskDraftsApiFp(configuration)
    return {
        /**
         * 
         * @param {ConvertDraftsDto} convertDraftsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerConvertToTasks(convertDraftsDto: ConvertDraftsDto, options?: any): AxiosPromise<ConvertDraftsResponseDto> {
            return localVarFp.taskDraftsControllerConvertToTasks(convertDraftsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTaskDraftDto} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreate(createTaskDraftDto: CreateTaskDraftDto, options?: any): AxiosPromise<TaskDraft> {
            return localVarFp.taskDraftsControllerCreate(createTaskDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerCreateBulk(createTaskDraftDto: Array<CreateTaskDraftDto>, options?: any): AxiosPromise<Array<TaskDraft>> {
            return localVarFp.taskDraftsControllerCreateBulk(createTaskDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindDraftsByCreator(options?: any): AxiosPromise<Array<TaskDraft>> {
            return localVarFp.taskDraftsControllerFindDraftsByCreator(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerFindOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.taskDraftsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.taskDraftsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerRemoveBulk(deleteDraftsBulkDto: DeleteDraftsBulkDto, options?: any): AxiosPromise<void> {
            return localVarFp.taskDraftsControllerRemoveBulk(deleteDraftsBulkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdate(id: string, updateTaskDraftDto: UpdateTaskDraftDto, options?: any): AxiosPromise<void> {
            return localVarFp.taskDraftsControllerUpdate(id, updateTaskDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateTaskDraftDto} updateTaskDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto: UpdateTaskDraftDto, options?: any): AxiosPromise<UpdateAndConvertDraftResponseDto> {
            return localVarFp.taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskDraftsApi - object-oriented interface
 * @export
 * @class TaskDraftsApi
 * @extends {BaseAPI}
 */
export class TaskDraftsApi extends BaseAPI {
    /**
     * 
     * @param {ConvertDraftsDto} convertDraftsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerConvertToTasks(convertDraftsDto: ConvertDraftsDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerConvertToTasks(convertDraftsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTaskDraftDto} createTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerCreate(createTaskDraftDto: CreateTaskDraftDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerCreate(createTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CreateTaskDraftDto>} createTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerCreateBulk(createTaskDraftDto: Array<CreateTaskDraftDto>, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerCreateBulk(createTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerFindDraftsByCreator(options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerFindDraftsByCreator(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteDraftsBulkDto} deleteDraftsBulkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerRemoveBulk(deleteDraftsBulkDto: DeleteDraftsBulkDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerRemoveBulk(deleteDraftsBulkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTaskDraftDto} updateTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerUpdate(id: string, updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerUpdate(id, updateTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateTaskDraftDto} updateTaskDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskDraftsApi
     */
    public taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto: UpdateTaskDraftDto, options?: AxiosRequestConfig) {
        return TaskDraftsApiFp(this.configuration).taskDraftsControllerUpdateAndConverToTask(updateTaskDraftDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreate: async (createTaskDto: CreateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('tasksControllerCreate', 'createTaskDto', createTaskDto)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<CreateTaskDto>} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreateBulk: async (createTaskDto: Array<CreateTaskDto>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTaskDto' is not null or undefined
            assertParamExists('tasksControllerCreateBulk', 'createTaskDto', createTaskDto)
            const localVarPath = `/tasks/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindAllUserTasks: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerFindOne', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerRemove', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdate: async (id: string, updateTaskDto: UpdateTaskDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksControllerUpdate', 'id', id)
            // verify required parameter 'updateTaskDto' is not null or undefined
            assertParamExists('tasksControllerUpdate', 'updateTaskDto', updateTaskDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerCreate(createTaskDto: CreateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerCreate(createTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<CreateTaskDto>} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerCreateBulk(createTaskDto: Array<CreateTaskDto>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerCreateBulk(createTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerFindAllUserTasks(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerFindAllUserTasks(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksControllerUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksControllerUpdate(id, updateTaskDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTaskDto} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreate(createTaskDto: CreateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksControllerCreate(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<CreateTaskDto>} createTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerCreateBulk(createTaskDto: Array<CreateTaskDto>, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksControllerCreateBulk(createTaskDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindAllUserTasks(limit?: number, offset?: number, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksControllerFindAllUserTasks(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerFindOne(id: string, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.tasksControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTaskDto} updateTaskDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksControllerUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: any): AxiosPromise<Task> {
            return localVarFp.tasksControllerUpdate(id, updateTaskDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @param {CreateTaskDto} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerCreate(createTaskDto: CreateTaskDto, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerCreate(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<CreateTaskDto>} createTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerCreateBulk(createTaskDto: Array<CreateTaskDto>, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerCreateBulk(createTaskDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerFindAllUserTasks(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerFindAllUserTasks(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerRemove(id: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTaskDto} updateTaskDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksControllerUpdate(id: string, updateTaskDto: UpdateTaskDto, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksControllerUpdate(id, updateTaskDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerFindOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate: async (id: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('usersControllerUpdate', 'body', body)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdate(id: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.usersControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.usersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate(id: string, body: object, options?: any): AxiosPromise<object> {
            return localVarFp.usersControllerUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindAll(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUpdate(id: string, body: object, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


